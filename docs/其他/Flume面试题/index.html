<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-其他/Flume面试题" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Flume面试题 | 大数据Guide</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/docs/其他/Flume面试题"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Flume面试题 | 大数据Guide"><meta data-rh="true" name="description" content="Flume架构"><meta data-rh="true" property="og:description" content="Flume架构"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/docs/其他/Flume面试题"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/其他/Flume面试题" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/其他/Flume面试题" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="大数据Guide RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="大数据Guide Atom Feed"><link rel="stylesheet" href="/assets/css/styles.69f2a557.css">
<script src="/assets/js/runtime~main.9ccc24a5.js" defer="defer"></script>
<script src="/assets/js/main.901e4aca.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">大数据Guide</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Flink/Flink SQL JOIN原理">大数据</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Flink/Flink SQL JOIN原理">Flink</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Hadoop/Hadoop实践">Hadoop</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Hive/Hive调优">Hive</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Kafka/Kafka实践">Kafka</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/OLAP/Clickhouse/Clickhouse存算分离">OLAP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Spark/Spark面试题1">Spark</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Zookeeper/Zookeeper面试题">Zookeeper</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/其他/Flume面试题">其他</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/其他/Flume面试题">Flume面试题</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/数据仓库/数仓架构建设方法论">数据仓库</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/数据湖/Iceberg/Iceberg实践">数据湖</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">其他</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Flume面试题</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Flume面试题</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="flume架构">Flume架构<a href="#flume架构" class="hash-link" aria-label="Direct link to Flume架构" title="Direct link to Flume架构">​</a></h2>
<p><img decoding="async" loading="lazy" alt="WX20240322-154252.png" src="/assets/images/WX20240322-154252-b164a632554ee971cd390127d0c05409.png" width="643" height="225" class="img_ev3q"></p>
<ol>
<li>
<p>Agent：Agent是一个JVM进程，它以事件（event）的形式将数据从源头送至目的。Agent主要有3个部分组成，Source、Channel、Sink。</p>
</li>
<li>
<p>Source：Source是专门用来收集数据的，将数据封装成Event发送给Channel。Source组件可以处理各种类型、各种格式的日志数据，包括netcat、avro、exec、spooling directory、taildir、thrift、jms、sequence generator、syslog、http、legacy。</p>
</li>
<li>
<p>Sink：Sink不断地轮询Channel中的事件且批量地移除它们，并将这些事件批量写入到存储系统、或者被发送到另一个Flume Agent。Sink组件目的地包括hdfs、logger、avro、thrift、ipc、file、HBase、solr、自定义。</p>
</li>
<li>
<p>Channel：Channel是位于Source和Sink之间的缓冲区。因此，Channel允许Source和Sink运作在不同的速率上。Channel是线程安全的，可以同时处理几个Source的写入操作和几个Sink的读取操作。Flume自带两种Channel：Memory Channel和File Channel。</p>
<ul>
<li>Memory Channel是内存中的队列。Memory Channel在不需要关心数据丢失的情景下适用。如果需要关心数据丢失，那么Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失</li>
<li>File Channel将所有事件写到磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据</li>
</ul>
</li>
<li>
<p>Event：传输单元，Flume数据传输的基本单元，Source接收数据，以Event的形式发送给Channel。Event由Header和Body两部分组成，Header用来存放该event的一些属性（默认为空），为K-V结构，Body用来存放该条数据，形式为字节数组</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="flume-agent的内部原理">Flume Agent的内部原理<a href="#flume-agent的内部原理" class="hash-link" aria-label="Direct link to Flume Agent的内部原理" title="Direct link to Flume Agent的内部原理">​</a></h2>
<p>主要组件</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="channelselector"><strong>ChannelSelector</strong><a href="#channelselector" class="hash-link" aria-label="Direct link to channelselector" title="Direct link to channelselector">​</a></h3>
<p>ChannelSelector的作用就是选出Event将要被发往哪个Channel。其共有两种类型，分别是Replicating（复制）和Multiplexing（多路复用）</p>
<p>ReplicatingSelector会将同一个Event发往所有的Channel，Multiplexing会根据相应的原则，将不同的Event发往不同的Channel。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="sinkprocessor"><strong>SinkProcessor</strong><a href="#sinkprocessor" class="hash-link" aria-label="Direct link to sinkprocessor" title="Direct link to sinkprocessor">​</a></h3>
<p>SinkProcessor共有三种类型，分别是DefaultSinkProcessor、LoadBalancingSinkProcessor和FailoverSinkProcessor</p>
<p>DefaultSinkProcessor对应的是单个的Sink（一对一），LoadBalancingSinkProcessor和FailoverSinkProcessor对应的是Sink Group（多个Sink），LoadBalancingSinkProcessor可以实现负载均衡的功能，FailoverSinkProcessor可以错误恢复（故障转移）的功能。</p>
<p>FailoverSinkProcessor（故障转移）可以设置优先级，优先选择级别高的sink发送数据，但是LoadBalancingSinkProcessor（负载均衡）不能设置优先级。</p>
<p>LoadBalancingSinkProcessor算法有两种，①random-随机分配 ②round_robin-轮循。</p>
<p>另外，如果一个Channel对接多个Sink,那么Channel中某一时刻的数据只能被一个Sink所获取，即同样的数据不能被发送到多个Sink。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="execsourcespooldir-sourcetaildir-source的区别">ExecSource 、Spooldir Source、Taildir Source的区别<a href="#execsourcespooldir-sourcetaildir-source的区别" class="hash-link" aria-label="Direct link to ExecSource、Spooldir Source、Taildir Source的区别" title="Direct link to ExecSource、Spooldir Source、Taildir Source的区别">​</a></h2>
<p>exec即execute执行的意思。表示执行Linux命令来读取文件。和tail -F命令搭配可以检测文件</p>
<p>Exec source适用于监控一个实时追加的文件，不能实现断点续传，就是说如果agent挂了，重新启动后（使用tail -f）会把文件的所有内容重新读一遍</p>
<p>Spooldir Source适合用于同步新文件，但不适合对实时追加日志的文件进行监听并同步。Spooldir Source读取的新文件以后会将其标记为.completed，但是，如果对已经读取的文件（即标记为.completed的文件）中追加新的内容，那么使用Spooldir Source是不行的，因为标记为.completed后，无论这个文件是否有变化，都不会再读取了。</p>
<p>而Taildir Source适合用于监听多个实时追加的文件，并且能够实现断点续传。即能够记录读取到的位置，agent重启后可以断点续读.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">## 一、Exec source配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a2.sources.r2.type = exec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a2.sources.r2.command = tail -F /opt/module/flume/demo/123.log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 二、Spooling Directory Source : 用来监听一个目录进行自动收集目录中的内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#1.当目录中某一个log文件的内容被读取完毕后，该文件有两种处理方案：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#  ①删除 ②在原来文件的名字后加.COMPLETED  --- 取决于 deletePolicy的设置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#2.在原来文件的名字后加.COMPLETED就是为标识该文件已经被读取完毕</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#注意 ：该目录中的文件名不能相同，如果相同则会抛异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a2.sources.r2.type = spooldir</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a2.sources.r2.spoolDir = /opt/module/flume/upload</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a2.sources.r2.fileSuffix = .COMPLETED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## 三、Taildir Source配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a3.sources.r3.type = TAILDIR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 文件中记录了source读取到的内容的位置,一旦taildir_position.json文件丢失那么source后从该文件的开始位置重新读</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a3.sources.r3.positionFile = /opt/module/flume/tail_dir.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a3.sources.r3.filegroups = f1 f2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a3.sources.r3.filegroups.f1 = /opt/module/flume/files/.*file.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a3.sources.r3.filegroups.f2 = /opt/module/flume/files2/.*log.*</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Taildir Source维护了一个json格式的position File，其会定期的往position File中更新每个文件读取到的最新的位置，因此能够实现断点续传。Position File的格式如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{&quot;inode&quot;:2496272,&quot;pos&quot;:12,&quot;file&quot;:&quot;/opt/module/flume/files/file1.txt&quot;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{&quot;inode&quot;:2496275,&quot;pos&quot;:12,&quot;file&quot;:&quot;/opt/module/flume/files/file2.txt&quot;}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Linux中储存文件元数据的区域就叫做inode，每个inode都有一个号码，操作系统用inode号码来识别不同的文件，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="flume的事务机制">Flume的事务机制<a href="#flume的事务机制" class="hash-link" aria-label="Direct link to Flume的事务机制" title="Direct link to Flume的事务机制">​</a></h2>
<p>Flume的事务机制（类似数据库的事务机制）：Flume使用两个独立的事务分别负责从Soucrce到Channel，以及从Channel到Sink的事件传递。</p>
<p><img decoding="async" loading="lazy" alt="WX20240322-154803.png" src="/assets/images/WX20240322-154803-3f75ef263f60f964098a03ba6f73b061.png" width="1357" height="550" class="img_ev3q"></p>
<p>思考：Take事务中的doRollback回滚的时候，如果Channel满了该怎么办？</p>
<p>不会出现这种情况，因为只有事务成功提交后才会将Channel中数据的空间释放【注意<!-- -->:doTake<!-- -->是从Channel中把数据拿走了，此时Channel中没有被拿走的数据，但是该数据所占用的存储空间没有被释放】，如果事务回滚，由于数据的空间没有被释放，所以可以直接拿来用。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="flume常用的拓扑结构">Flume常用的拓扑结构<a href="#flume常用的拓扑结构" class="hash-link" aria-label="Direct link to Flume常用的拓扑结构" title="Direct link to Flume常用的拓扑结构">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单串联">简单串联<a href="#简单串联" class="hash-link" aria-label="Direct link to 简单串联" title="Direct link to 简单串联">​</a></h3>
<p><img decoding="async" loading="lazy" alt="img.png" src="/assets/images/img-ba7f069070fe0a031b48a5f27c2b4861.png" width="664" height="143" class="img_ev3q"></p>
<p>这种模式是将多个flume顺序连接起来了，从最初的source开始到最终sink传送的目的存储系统。此模式不建议桥接过多的flume数量， flume数量过多不仅会影响传输速率，而且一旦传输过程中某个节点flume宕机，会影响整个传输系统。</p>
<p>简单串联的第一个Flume的Sink类型为Avro。</p>
<p>Avro指的是序列化（不同的进程数据之间的传递需要进行序列化，即把对象序列化到磁盘，再从磁盘中读取转化为内存中的对象）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="复制和多路复用">复制和多路复用<a href="#复制和多路复用" class="hash-link" aria-label="Direct link to 复制和多路复用" title="Direct link to 复制和多路复用">​</a></h3>
<blockquote>
<p>这是对ChannelSelector来说的
<img decoding="async" loading="lazy" alt="img_1.png" src="/assets/images/img_1-9da553ea883ec80127e0c21bd16cdad0.png" width="607" height="356" class="img_ev3q"></p>
</blockquote>
<p>Flume支持将事件流向一个或者多个目的地。这种模式可以将相同数据复制到多个channel中，或者将不同数据分发到不同的channel中（多路复用），sink可以选择传送到不同的目的地。</p>
<p>使用这种方式需要将sources的type设置为replicating或者multiplexing</p>
<div class="language-shel codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shel codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">a1.sources = r1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#一、复制(默认不配也可以)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sources.r1.selector.type = replicating</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#二、复用 (如果是复制，下面四个选项就不用配置了)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sources.r1.selector.type = multiplexing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#event(headers | body)根据headers中的key和value进行数据的发送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#state指的是headers，key的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sources.r1.selector.header = state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#CZ指的是key对应的value值那么就发送到channel1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sources.r1.selector.mapping.CZ = c1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#US指的是key对应的value值那么就发送到channel2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sources.r1.selector.mapping.US = c2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="负载均衡和故障转移">负载均衡和故障转移<a href="#负载均衡和故障转移" class="hash-link" aria-label="Direct link to 负载均衡和故障转移" title="Direct link to 负载均衡和故障转移">​</a></h3>
<blockquote>
<p>这是SinkProcessor
<img decoding="async" loading="lazy" alt="img_2.png" src="/assets/images/img_2-677520e4cee9109b521f1b84792f7a7b.png" width="784" height="399" class="img_ev3q"></p>
</blockquote>
<p>Flume支持使用将多个sink逻辑上分到一个sink组，sink组配合不同的SinkProcessor（即LoadBalancingSinkProcessor或FailoverSinkProcessor）可以实现负载均衡和错误恢复的功能</p>
<p>SinkProcessor共有三种类型，分别是DefaultSinkProcessor、LoadBalancingSinkProcessor和FailoverSinkProcessor。</p>
<p>DefaultSinkProcessor对应的是单个的Sink（一对一），LoadBalancingSinkProcessor和FailoverSinkProcessor对应的是Sink Group（多个Sink）</p>
<div class="language-she codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-she codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinks = k1 k2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#一、配置failover故障转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#该sink组有哪些sink的实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.sinks = k1 k2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#配置sinkProcessor的类型①failover故障转移 ②load_balance负载均衡</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.processor.type = failover</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#配置sink的优先级数值越大优先级越高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.processor.priority.k1 = 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.processor.priority.k2 = 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#二、load_balance负载均衡</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#定义一个sink组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups = g1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#指明sink组中的sink实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.sinks = k1 k2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#设置sinkProcessor的类型（负载均衡）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.processor.type = load_balance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#①random-随机分配  ②round_robin-轮循</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">a1.sinkgroups.g1.processor.selector = random</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="聚合功能">聚合功能<a href="#聚合功能" class="hash-link" aria-label="Direct link to 聚合功能" title="Direct link to 聚合功能">​</a></h3>
<p><img decoding="async" loading="lazy" alt="img_3.png" src="/assets/images/img_3-d6688e5aa165b845d4ae9579282a23cd.png" width="717" height="519" class="img_ev3q"></p>
<p>这种模式是我们最常见的，也非常实用，日常web应用通常分布在上百个服务器，大者甚至上千个、上万个服务器。产生的日志，处理起来也非常麻烦。用flume的这种组合方式能很好的解决这一问题，每台服务器部署一个flume采集日志，传送到一个集中收集日志的flume，再由此flume上传到hdfs、hive、hbase等，进行日志分析 。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="你是如何实现flume数据传输监控的">你是如何实现Flume数据传输监控的<a href="#你是如何实现flume数据传输监控的" class="hash-link" aria-label="Direct link to 你是如何实现Flume数据传输监控的" title="Direct link to 你是如何实现Flume数据传输监控的">​</a></h2>
<p>通过Ganglia进行监控。</p>
<p>Ganglia由gmond、gmetad和gweb三部分组成。</p>
<p>gmond（Ganglia Monitoring Daemon）是一种轻量级服务，安装在每台需要收集指标数据的节点主机上。使用gmond，你可以很容易收集很多系统指标数据，如CPU、内存、磁盘、网络和活跃进程的数据等。（每台机器上都要安装）
gmetad（Ganglia Meta Daemon）整合所有信息，并将其以RRD格式存储至磁盘的服务。（只需在主服务器上安装即可）
gweb（Ganglia Web）Ganglia可视化工具，gweb是一种利用浏览器显示gmetad所存储数据的PHP前端。在Web界面中以图表方式展现集群的运行状态下收集的多种不同指标数据。（只需在主服务器上安装即可）</p>
<p>监控界面如图所示
<img decoding="async" loading="lazy" alt="img_4.png" src="/assets/images/img_4-42a3a802cdabc5fec38b2b4030d172b0.png" width="1303" height="338" class="img_ev3q"></p>
<p>图例说明：</p>
<p>字段（图表名称）	字段含义
EventPutAttemptCount	source尝试写入channel的事件总数量
EventPutSuccessCount	成功写入channel且提交的事件总数量
EventTakeAttemptCount	sink尝试从channel拉取事件的总数量。
EventTakeSuccessCount	sink成功读取的事件的总数量
StartTime	channel启动的时间（毫秒）
StopTime	channel停止的时间（毫秒）
ChannelSize	目前channel中事件的总数量
ChannelFillPercentage	channel占用百分比
ChannelCapacity	channel的容量</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="你公司采用的source类型是什么">你公司采用的Source类型是什么<a href="#你公  司采用的source类型是什么" class="hash-link" aria-label="Direct link to 你公司采用的Source类型是什么" title="Direct link to 你公司采用的Source类型是什么">​</a></h2>
<p>监控后台日志：exec、spooldir、TAILDIR</p>
<p>监控后台产生日志的端口：netcat</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="简单介绍下flume的参数调优">简单介绍下Flume的参数调优<a href="#简单介绍下flume的参数调优" class="hash-link" aria-label="Direct link to 简单介绍下Flume的参数调优" title="Direct link to 简单介绍下Flume的参数调优">​</a></h2>
<p>（1）Source</p>
<p>增加Source个数（使用TairDir Source时可增加FileGroups个数）可以增大Source的读取数据的能力。例如：当某一个目录产生的文件过多时需要将这个文件目录拆分成多个文件目录，同时配置好多个Source 以保证Source有足够的能力获取到新产生的数据。</p>
<p>batchSize参数决定Source一次性往putList放event的个数，适当调大这个参数可以提高Source搬运Event到Channel时的性能。（execSource的batchSize默认为20）。</p>
<p>（2）Channel</p>
<p>type 选择memory时Channel的性能最好，但是如果Flume进程意外挂掉可能会丢失数据。type选择file时Channel的容错性更好，但是性能上会比memory channel差。不过实际生产时选memory多一些。</p>
<p>我们也可以使用file Channel时dataDirs配置多个不同盘下的目录可以提高性能。</p>
<p>Capacity参数决定Channel可容纳最大的event条数。transactionCapacity 参数决定每次Source往channel里面写的最大event条数和每次Sink从channel里面读的最大event条数。transactionCapacity需要大于Source和Sink的batchSize参数。</p>
<p>（3）Sink</p>
<p>增加Sink的个数可以增加Sink消费event的能力。Sink也不是越多越好够用就行，过多的Sink会占用系统资源，造成系统资源不必要的浪费。
batchSize参数决定Sink一次批量从takeList 读取的event条数，适当调大这个参数可以提高Sink从Channel搬出event的性能。（注意：不仅source有batchSize，Sink里也有batchSize）。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="数据怎么采集到kafka实现方式">数据怎么采集到Kafka，实现方式<a href="#数据怎么采集到kafka实现方式" class="hash-link" aria-label="Direct link to 数据怎么采集到Kafka，实现方式" title="Direct link to 数据怎么采集到Kafka，实现方式">​</a></h2>
<blockquote>
<p>flume写数据到kafka分为2种：</p>
</blockquote>
<ul>
<li>第一种方式：netcatSource-&gt;memeory channel-&gt;kafkaSink</li>
<li>第二种方式：netcatSource-&gt;kafka channel</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="flume和kafka采集日志区别采集的中间件停了该怎么办">flume和kafka采集日志区别，采集的中间件停了该怎么办<a href="#flume和kafka采集日志区别采集的中间件停了该怎么办" class="hash-link" aria-label="Direct link to flume和kafka采集日志区别，采集的中间件停了该怎么办" title="Direct link to flume和kafka采集日志区别，采集的中间件停了该怎么办">​</a></h2>
<p>Flume采集日志是通过流的方式直接将日志收集到存储层，Sink写入数据到目的地后，就把Channel中相应的event移出了。</p>
<p>kafka是将数据缓存到kafka集群（默认在磁盘上报错7天，如果有必要可以设置为永久），消费者可以指定offset访问分区内任意数据。kafka中数据的删除跟有没有消费者消费完全无关。</p>
<p>如果在采集日志中，采集的中间件停了该怎么办？</p>
<p>对于Flume来说，如果Sink没有从Channel中获取数据，那么Channel中的数据会一直存在。具体来说，是通过Channel到Sink的事务进行的，该事物有三个操作dotake、docommit、dorollback，如果Sink没有获取数据，即dotake无法把takeList中的数据发送给sink，那么docommit就会执行失败，此  时会执行dorollback方法，将数据归还给channel，同时清空缓冲区，所以如果sink没有将数据写出去，数据会一直在channel。</p>
<p>这时候你会想，channel中的数据无法被sink取出，那channel满了怎么办？如果channel满了，那么source往channel发送数据的事务就会失败，即doput将source的数据放入putlist后，commit检查channel中没有足够的空间了，那么就会执行doroollback方法，给source抛出异常，同时将putlist中的数据清空，之后source会重复发送数据。</p>
<p>memeory channel的默认容量是100个event，file channel默认容量是100万个event</p>
<p>所以对于Flume来说，如果其采集数据的中间件停了，两个事物都会执行失败，source会一直尝试向channel发送数据，sink会一直尝试从channel读取数据发往采集的中间件，然后失败、抛异常、回滚。
另外，补充一个参数：maxBackoff
这个参数代表当source向channel放数据时检测到channel满了后等待多久再进行重试，默认是4秒。</p>
<p>对于kafka来说，由于消费者可以通过offset从上次的位置读取数据，所以就算其消费者挂了，也没有关系。并且，kafka的数据是持久化到磁盘上，其数据的删除跟有没有消费者消费完全无关，新版kafka的数据的生命周期为7天</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="简单介绍一下flume的使用场景">简单介绍一下Flume的使用场景<a href="#简单介绍一下flume的使用场景" class="hash-link" aria-label="Direct link to 简单介绍一下Flume的使用场景" title="Direct link to 简单介绍一下Flume的使用场景">​</a></h2>
<ol>
<li>日志采集和传输，采集多种日志到目的地</li>
<li>日志聚合
日常web应用通常分布在上百个服务器，大者甚至上千个、上万个服务器。产生的日志，处理起来也非常麻烦。用flume的这种组合方式能很好的解决这一问题，每台服务器部署一个flume采  集日志，传送到一个集中收集日志的flume，再由此flume上传到hdfs、hive、hbase等，进行日志分析</li>
<li>结合Kafka使用，Flume和Kafka可以很好地结合起来使用。如果你的设计需要从Kafka到Hadoop的流数据，使用Flume配置Kafka source读取数据kafka中的数据，然后写入到HDFS中，当然你也可以自己实现kafka的消费者，但这完全没有必要。</li>
<li>也可以将日志采集到kafka供多个消费者消费，Kafka中的数据通过Flume采集到存储系统上</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="flume不采集nginx日志通过logger4j采集日志优缺点是什么">flume不采集Nginx日志，通过Logger4j采集日志，优缺点是什么<a href="#flume不采集nginx日志通过logger4j采集日志优缺点是什么" class="hash-link" aria-label="Direct link to flume不采集Nginx日志，通过Logger4j采集日志，优缺点是什么" title="Direct link to flume不采集Nginx日志，通过Logger4j采集日志，优缺点是什么">​</a></h2>
<p>优点：Nginx的日志格式是固定的，但是缺少sessionid，通过logger4j采集的日志是带有sessionid的，而session可以通过redis共享，保证了集群日志中的同一session落到不同的tomcat时，sessionId还是一样的，而且logger4j的方式比较稳定，不会宕机。</p>
<p>缺点：不够灵活，logger4j的方式和项目结合过于紧密，而flume的方式比较灵活，拔插式比较好，不会影响项目性能。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/其他/Flume面试题.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Zookeeper/Zookeeper面试题"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Zookeeper面试题</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/数据仓库/数仓架构建设方法论"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">数仓架构建设方法论</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#flume架构" class="table-of-contents__link toc-highlight">Flume架构</a></li><li><a href="#flume-agent的内部原理" class="table-of-contents__link toc-highlight">Flume Agent的内部原理</a><ul><li><a href="#channelselector" class="table-of-contents__link toc-highlight"><strong>ChannelSelector</strong></a></li><li><a href="#sinkprocessor" class="table-of-contents__link toc-highlight"><strong>SinkProcessor</strong></a></li></ul></li><li><a href="#execsourcespooldir-sourcetaildir-source的区别" class="table-of-contents__link toc-highlight">ExecSource、Spooldir Source、Taildir Source的区别</a></li><li><a href="#flume的事务机制" class="table-of-contents__link toc-highlight">Flume的事务机制</a></li><li><a href="#flume常用的拓扑结构" class="table-of-contents__link toc-highlight">Flume常用的拓扑结构</a><ul><li><a href="#简单串联" class="table-of-contents__link toc-highlight">简单串联</a></li><li><a href="#复制和多路复用" class="table-of-contents__link toc-highlight">复制和多路复用</a></li><li><a href="#负载均衡和故障转移" class="table-of-contents__link toc-highlight">负载均衡和故障转移</a></li><li><a href="#聚合功能" class="table-of-contents__link toc-highlight">聚合功能</a></li></ul></li><li><a href="#你是如何实现flume数据传输监控的" class="table-of-contents__link toc-highlight">你是如何实现Flume数据传输监控的</a></li><li><a href="#你公司采用的source类型是什么" class="table-of-contents__link toc-highlight">你公司采用的Source类型是什么</a></li><li><a href="#简单介绍下flume的参数调优" class="table-of-contents__link toc-highlight">简单介绍下Flume的参数调优</a></li><li><a href="#数据怎么采集到kafka实现方式" class="table-of-contents__link toc-highlight">数据怎么采集到Kafka，实现方式</a></li><li><a href="#flume和kafka采集日志区别采集的中间件停了该怎么办" class="table-of-contents__link toc-highlight">flume和kafka采集日志区别，采集的中间件停了该怎么办</a></li><li><a href="#简单介绍一下flume的使用场景" class="table-of-contents__link toc-highlight">简单介绍一下Flume的使用场景</a></li><li><a href="#flume不采集nginx日志通过logger4j采集日志优缺点是什么" class="table-of-contents__link toc-highlight">flume不采集Nginx日志，通过Logger4j采集日志，优缺点是什么</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>