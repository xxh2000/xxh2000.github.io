<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Flink/Flink WaterMark详解" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Flink WaterMark详解 | 大数据Guide</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/docs/Flink/Flink WaterMark详解"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Flink WaterMark详解 | 大数据Guide"><meta data-rh="true" name="description" content="Watermark的作用"><meta data-rh="true" property="og:description" content="Watermark的作用"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/docs/Flink/Flink WaterMark详解"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/Flink/Flink WaterMark详解" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/Flink/Flink WaterMark详解" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="大数据Guide RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="大数据Guide Atom Feed"><link rel="stylesheet" href="/assets/css/styles.69f2a557.css">
<script src="/assets/js/runtime~main.9ccc24a5.js" defer="defer"></script>
<script src="/assets/js/main.901e4aca.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">大数据Guide</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/Flink/Flink SQL JOIN原理">大数据</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/Flink/Flink SQL JOIN原理">Flink</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Flink/Flink SQL JOIN原理">Flink SQL JOIN原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/Flink/Flink WaterMark详解">Flink WaterMark详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Flink/FlinkCheckpoint源码分析">FlinkCheckpoint源码分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Flink/Flink实践">Flink实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Flink/Flink维表关联方案">Flink维表关联方案</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Flink/Flink面试题">Flink面试题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/Flink/实时数仓架构选型">实时数仓架构选型</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Hadoop/Hadoop实践">Hadoop</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Hive/Hive调优">Hive</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Kafka/Kafka实践">Kafka</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/OLAP/Clickhouse/Clickhouse存算分离">OLAP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Spark/Spark面试题1">Spark</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Zookeeper/Zookeeper面试题">Zookeeper</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/其他/Flume面试题">其他</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/数据仓库/数仓架构建设方法论">数据仓库</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/数据湖/Iceberg/Iceberg实践">数据湖</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Flink</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Flink WaterMark详解</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Flink WaterMark详解</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="watermark的作用">Watermark的作用<a href="#watermark的作用" class="hash-link" aria-label="Direct link to Watermark的作用" title="Direct link to Watermark的作用">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="概述">概述<a href="#概述" class="hash-link" aria-label="Direct link to 概述" title="Direct link to 概述">​</a></h3>
<p>什么是水位线呢？先来看一个例子，假如要每5分钟统计一次过去1个小时内的热门商品的topN，这是一个典型的滑动窗口操作，那么基于事件时间的窗口该在什么时候出发计算呢？换句话说，我们要等多久才能够确定已经接收到了特定时间点之前的所有事件，另一方面，由于网络延迟等原因，会产生乱序的数据，在进行窗口操作时，不能够无限期的等待下去，需要一个机制来告诉窗口在某个特定时间来触发window计算，即认为小于等于该时间点的数据都已经到来了。这个机制就是watermark(水位线)，可以用来处理乱序事件。</p>
<p>水位线是一个全局的进度指标，表示可以确定不会再有延迟的事件到来的某个时间点。从本质上讲，水位线提供了一个逻辑时钟，用来通知系统当前的事件时间。比如，当一个算子接收到了W(T)时刻的水位线，就可以大胆的认为不会再接收到任何时间戳小于或等于W(T)的事件了。水位线对于基于事件时间的窗口和处理乱序数据是非常关键的，算子一旦接收到了某个水位线，就相当于接到一支穿云箭的信号：所有特定时间区间的数据都已集结完毕，可以进行窗口触发计算。</p>
<p>既然已经说了，事件是会存在乱序的，那这个乱序的程度究竟有多大呢，这个就不太好确定了，总之总会有些迟到的事件慢慢悠悠的到来。所以，水位线其实是一种在<strong>准确性</strong>与<strong>延迟</strong>之间的权衡，如果水位线设置的非常苛刻，即不允许有掉队的数据出现，虽然准确性提高了，但这在无形之中增加了数据处理的延迟。反之，如果水位线设置的非常激进，即允许有迟到的数据发生，那么虽然降低了数据处理的延迟，但数据的准确性会较低。</p>
<p>所以，水位线是中庸之道，过犹不及。在很多现实应用中，系统无法获取足够多的信息来确定完美的水位线，那么该怎么办呢？Flink提供了某些机制来处理那些可能晚于水位线的迟到时间，用户可以根据应用的需求不同，可以将这些漏网之鱼(迟到的数据)舍弃掉，或者写入日志，或者利用他们修正之前的结果</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="水位线图解">水位线图解<a href="#水位线图解" class="hash-link" aria-label="Direct link to 水位线图解" title="Direct link to 水位线图解">​</a></h3>
<p>在上一小节，通过语 言描述对水位线的概念进行了详细解读，在本小节会通过图解的方式解析水位线的含义，这样更能加深对水位线的理解。如下图所示
<img decoding="async" loading="lazy" alt="水位线图解1.png" src="/assets/images/水位线图解1-bc2c5081550b872cf402712ca4ab5247.png" width="771" height="339" class="img_ev3q"></p>
<p>如上图，矩形表示一条记录，三角表示该条记录的时间戳(真实发生时间)，圆圈表示水位线。可以看到上面的数据是乱序的，比如当算子接收到为2的水位线时，就可以认为时间戳小于等于2的数据都已经到来了，此时可以触发计算。同理，接收到为5的水位线时，就可以认为时间戳小于或等于5的数据都已经到来了，此时可以触发计算。</p>
<p>可以看出水位线是单调递增的，并且和记录的时间戳存在联系，一个时间戳为T的水位线表示接下来所有记录的时间戳一定都会大于T。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="水位线的传播">水位线的传播<a href="#水位线的传播" class="hash-link" aria-label="Direct link to 水位线的传播" title="Direct link to 水位线的传播">​</a></h3>
<p>可参考：</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/weixin_43527591/article/details/128886374" target="_blank" rel="noopener noreferrer">Flink水位线传递_flink水位线的传递-CSDN博客</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/weixin_45201661/article/details/122517032?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8-122517032-blog-121666563.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;spm=1001.2101.3001.4242.5&amp;utm_relevant_index=11" target="_blank" rel="noopener noreferrer">Flink并行运行情况下watermark的传递机制_flink中并行时watermark如何传递-CSDN博客</a></p>
</li>
</ul>
<p>现在，或许你已经对水位线是什么有了一个初步的认识，接下来将会介绍水位线是怎么在Flink内部 传播的。关于水位线的传播策略可以归纳为3点：</p>
<ul>
<li>首先，水位线是以广播的形式在算子之间进行传播</li>
<li>Long.MAX_VALUE表示事件时间的结束，即未来不会有数据到来了</li>
<li>单个分区的输入取最大值，多个分区的输入取最小值</li>
</ul>
<p>关于Long.MAX_VALUE的解释，先看一段代码，如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> /** </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 当一个source关闭时，会输出一个Long.MAX_VALUE的水位线，当一个算子接收到该水位线时，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 相当于接收到一个信号：未来不会再有数据输入了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PublicEvolving</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class Watermark extends StreamElement {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	//表示事件时间的结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public static final Watermark MAX_WATERMARK = new Watermark(Long.MAX_VALUE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>关于另外两条策略的解释，可以从下图中得到：
<img decoding="async" loading="lazy" alt="水位线传播.png" src="/assets/images/水位线传播-d116a193542c0f249fc7250578390cfa.png" width="943" height="589" class="img_ev3q"></p>
<p>如上图，一个任务会为它的每个分区都维护一个分区水位线(partition watermark)，当收到每个分区传来的水位线时，任务首先会让当前分区水位线的值与接收的水位线值相比较，如果新接收的水位线值大于当前分区水位线值，则会将对应的分区水位线值更新为较大的水位线值(如上图中的2步骤)，接着，任务会把事件时钟调整为当前分区水位线值的最小值，如上图步骤2 ，由于当前分区水位线的最小值为3，所以将事件时间时钟更新为3，然后将值为3的水位线广播到下游任务。步骤3与步骤4的处理逻辑同上。</p>
<p>同时我们可以注意到这种设计其实有一个局限，具体体现在没有对分区(partition)是否来自于不同的流进行区分，比如对于两条流或多条流的Union或Connect操作，同样是按照全部分区水位线中最小值来更新事件时间时钟，这就导致所有的输入记录都会按照基于同一个事件时间时钟来处理，这种一刀切的做法对于同一个流的不同分区而言是无可厚非的，但是对于多条流而言，强制使用一个时钟进行同步会对整个集群带来较大的性能开销，比如当两个流的水位线相差很大是，其中的一个流要等待最慢的那条流，而较快的流的记录会在状态中缓存，直到事件时间时钟到达允许处理它们的那个时间点。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="水位线的生成方式">水位线的生成方式<a href="#水位线的生成方式" class="hash-link" aria-label="Direct link to 水位线的生成方式" title="Direct link to 水位线的生成方式">​</a></h3>
<p>通常情况下，在接收到数据源之后应该马上为其生成水位线，即越靠近数据源越好。Flink提供两种方式生成水位线，其中一种方式为在数据源完成的，即利用SourceFunction在应用读入数据流的时候分配时间戳与水位线。另一种方式是通过实现接口的自定义函数，该方式又包括两种实现方式：一种为周期性生成水位线，即实现AssignerWithPeriodicWatermarks接口，另一种为定点生成水位线，即实AssignerWithPunctuatedWatermarks接口。具体如下图所示：
<img decoding="async" loading="lazy" alt="水位线生成方式.png" src="/assets/images/水位线生成方式-e536f455b5b28bc0308f84fc28e47aa1.png" width="1196" height="211" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="数据源方式">数据源方式<a href="#数据源方式" class="hash-link" aria-label="Direct link to 数据源方式" title="Direct link to 数据源方式">​</a></h4>
<p>该方式主要是实现自定义数据源，数据源分配时间戳和水位线主要是通过内部的SourceContext对象实现的，先看一下SourceFunction的源码，如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface SourceFunction&lt;T&gt; extends Function, Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	void cancel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	interface SourceContext&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		void collect(T element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 用于输出记录并附属一个与之关联的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		@PublicEvolving</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		void collectWithTimestamp(T element, long timestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 用于输出传入的水位线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		@PublicEvolving</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		void emitWatermark(Watermark mark);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 将自身标记为空闲状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 某个某个分区不在产生数据，会阻碍全局水位线前进，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 因为收不到新的记录，意味着不会发出新的水位线，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 根据水位线的传播策略，会导致整个应用都停止工作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* Flink提供一种机制，将数据源函数暂时标记为空闲，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		* 在空闲状态下，Flink水位线的传播机制会忽略掉空闲的数据流分区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		@PublicEvolving</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		void markAsTemporarilyIdle();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		Object getCheckpointLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		void close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从上面对的代码可以看出，通过SourceContext对象的方法可以实现时间戳与水位线的分配。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="自定义函数的方式">自定义函数的方式<a href="#自定义函数的方式" class="hash-link" aria-label="Direct link to 自定义函数的方式" title="Direct link to 自定义函数的方式">​</a></h4>
<p>使用自定义函数的方式分配时间戳，只需要调用assignTimestampsAndWatermarks()方法，传入一个实现AssignerWithPeriodicWatermarks或者AssignerWithPunctuatedWatermarks接口的分配器即可，如下代码所示：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SingleOutputStreamOperator&lt;UserBehavior&gt; userBehavior = env</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .addSource(new MysqlSource())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .assignTimestampsAndWatermarks(new MyTimestampsAndWatermarks());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li><strong>周期分配器(AssignerWithPeriodicWatermarks)</strong></li>
</ul>
<p>该分配器是实现了一个AssignerWithPeriodicWatermarks的用户自定义函数，通过重写extractTimestamp()方法来提取时间戳，提取出来的时间戳会附加在各自的记录上，查询得到的水位线会注入到数据流中。</p>
<p>周期性的生成水位线是指以固定的时间间隔来发出水位线并推进事件时间的前进，关于默认的时间间隔在上文中也有提到，根据选择的时间语义确定默认的时间间隔，如果使用Processing Time或者Event Time，默认的水位线间隔时间是200毫秒，当然用户也可以自己设定时间间隔，关于如何设定，先看一段代码，代码来自于ExecutionConfig类：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 设置生成水位线的时间间隔</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 注：自动生成watermarks的时间间隔不能是负数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PublicEvolving</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ExecutionConfig setAutoWatermarkInterval(long interval) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Preconditions.checkArgument(interval &gt;= 0, &quot;Auto watermark interval must not be negative.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	this.autoWatermarkInterval = interval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>所以，如果要调整默认的200毫秒的间隔，可以调用setAutoWatermarkInterval()方法，具体使用  如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  //每3秒生成一次水位线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">env.getConfig().setAutoWatermarkInterval(3000);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上面指定了每隔3秒生成一次水位线，即每隔3秒会自动向流里注入一个水位线，在代码层面，Flink会每隔3秒钟调用一次AssignerWithPeriodicWatermarks的getCurrentWatermark()方法，每次调用该方法时，如果得到的值不为空并且大于上一个水位线的时间戳，那么就会向流中注入一个新的水位线。这项检查可以有效地保证了事件时间的递增的特性，一旦检查失败也就不会生成水位线。下面给出一个实现周期分配水位线的例子：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyTimestampsAndWatermarks implements AssignerWithPeriodicWatermarks&lt;UserBehavior&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义1分钟的容忍间隔时间，即允许数据的最大乱序时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long maxOutofOrderness = 60 * 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 观察到的最大时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long currentMaxTs = Long.MIN_VALUE;      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Nullable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Watermark getCurrentWatermark() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 生成具有1分钟容忍度的水位线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Watermark(currentMaxTs - maxOutofOrderness);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long extractTimestamp(UserBehavior element, long previousElementTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取当前记录的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long currentTs = element.timestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新最大的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        currentMaxTs = Math.max(currentMaxTs, currentTs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回记录的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return currentTs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>通过查看TimestampAssignerd 继承关系可以发现(继承关系如下图)，除此之外，Flink还提供了两种内置的水位线分配器，分别为：AscendingTimestampExtractor和BoundedOutOfOrdernessTimestampExtractor两个抽象类。</p>
<p><img decoding="async" loading="lazy" alt="内置水位线分配器.png" src="/assets/images/内置水位线分配器-6d9582976a84eb94468507d1e4b9962e.png" width="989" height="300" class="img_ev3q"></p>
<p>关于<strong>AscendingTimestampExtractor</strong>，一般是在数据集的时间戳是单调递增的且没有乱序时使用，该方法使用当前的时间戳生成水位线，使用方式如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SingleOutputStreamOperator&lt;UserBehavior&gt; userBehavior = env</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .addSource(new MysqlSource())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .assignTimestampsAndWatermarks(new AscendingTimestampExtractor&lt;UserBehavior&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    public long extractAscendingTimestamp(UserBehavior element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return element.timestamp*1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>关于<strong>BoundedOutOfOrdernessTimestampExtractor</strong>，是在数据集中存在乱序数据的情况下使用，即数据有延迟(任意新到来的元素与已经到来的时间戳最大的元素之间的时间差)，这种方式可以接收一个表示最大预期延迟参数，具体如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SingleOutputStreamOperator&lt;UserBehavior&gt; userBehavior = env</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .addSource(new MysqlSource())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;UserBehavior&gt;(Time.seconds(10)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    public long extractTimestamp(UserBehavior element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return element.timestamp*1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>上述的代码接收了一个10秒钟延迟的参数，这10秒钟意味着如果当前元素的事件时间与到达的元素的最大时间戳的差值在10秒之内，那么该元素会被处理，如果差值超过10秒，表示其本应该参与的计算，已经完成了，Flink称之为迟到的数据，Flink提供了不同的策略来处理这些迟到的数据。</p>
<ul>
<li><strong>定点水位线分配器(AssignerWithPunctuatedWatermarks)</strong></li>
</ul>
<p>该方式是基于某些事件(指示系统进度的特殊元祖或标记)触发水位线的生成与发送，基于特定的事件向流中注入一个水位线，流中的每一个元素都有机会判断是否生成一个水位线，如果得到的水位线不为空并且大于之前的水位线，就生成水位线并注入流中。</p>
<p>实现AssignerWithPunctuatedWatermarks接口，重写checkAndGetNextWatermark()方法，该方法会在针对每个事件的extractTimestamp()方法后立即调用，以此来决定是否生成一个新的水位线，如果该方法返回一个非空并且大于之前值的水位线，就会将这个新的水位线发出。</p>
<p>下面将会实现一个简单的定点水位线分配器</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyPunctuatedAssigner implements AssignerWithPunctuatedWatermarks&lt;UserBehavior&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义1分钟的容忍间隔时间，即允许数据的最大乱序时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long maxOutofOrderness = 60 * 1000;      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Nullable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Watermark checkAndGetNextWatermark(UserBehavior element, long extractedTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果读取数据的用户行为是购买，就生成水位线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(element.action.equals(&quot;buy&quot;)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           return new Watermark(extractedTimestamp - maxOutofOrderness);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 不发出水位线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public long extractTimestamp(UserBehavior element, long previousElementTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return element.timestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="迟到的数据">迟到的数据<a href="#迟到的数据" class="hash-link" aria-label="Direct link to 迟到的数据" title="Direct link to 迟到的数据">​</a></h3>
<p>上文已经说过，现实中很难生成一个完美的水位线，水位线就是在延迟与准确性之前做的一种权衡。那么，如果生成的水位线过于紧迫，即水位线可能会大于后来数据的时间戳，这就意味着数据有延迟，关于延迟数据的处理，Flink提供了一些机制，具体如下：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="直接将迟到的数据丢弃">直接将迟到的数据丢弃<a href="#直接将迟到的数据丢弃" class="hash-link" aria-label="Direct link to 直接将迟到的数据丢弃" title="Direct link to 直接将迟到的数据丢弃">​</a></h4>
<p>如果不做其他操  作，默认情况下迟到数据会被直接丢弃。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="将迟到的数据输出到单独的数据流中">将迟到的数据输出到单独的数据流中<a href="#将迟到的数据输出到单独的数据流中" class="hash-link" aria-label="Direct link to 将迟到的数据输出到单独的数据流中" title="Direct link to 将迟到的数据输出到单独的数据流中">​</a></h4>
<p>即使用<code>sideOutputLateData(new OutputTag&lt;&gt;()）</code>实现侧输出</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 数据流有三个字段：（key, 时间戳, 数值）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val input: DataStream[(String, Long, Int)] = ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val mainStream = input.keyBy(item =&gt; item._1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .timeWindow(Time.seconds(5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将输出写到late-elements里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .sideOutputLateData(new OutputTag[(String, Long, Int)](&quot;late-elements&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .aggregate(new CountAggregate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 接受late-elements，形成一个数据流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val lateStream: DataStream[(String, Long, Int)] = mainStream.getSideOutput(new OutputTag[(String, Long, Int)](&quot;late-elements&quot;))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="根据迟到的事件更新并发出结果">根据迟到的事件更新并发出结果<a href="#根据迟到的事件更新并发出结果" class="hash-link" aria-label="Direct link to 根据迟到的事件更新并发出结果" title="Direct link to 根据迟到的事件更新并发出结果">​</a></h4>
<p>对于迟到数据，使用上面两种方法，都对计算结果的正确性有影响。如果将数据流发送到单独的侧输出，我们仍然需要完成单独的处理逻辑，相对比较复杂。更理想的情况是，将迟到数据重新进行一次，得到一个更新的结果。<code>allowedLateness</code>允许用户在Event Time下对某个窗口先得到一个结果，如果在一定时间内有迟到数据，迟到数据会和之前的数据一起重新被计算，以得到一个更准确的结果。使用这个功能时需要注意，原来窗口中的状态数据在窗口已经触发的情况下仍然会被保留，否则迟到数据到来后也无法与之前数据融合。另一方面，更新的结果要以一种合适的形式输出到外部系统，或者将原来结果覆盖，或者同时保存且有时间戳以表明来自更新后的计算。比如，  我们的计算结果是一个键值对（Key-Value），我们可以把这个结果输出到Redis这样的KV数据库中，使用某些Reids命令，对于同一个Key下，旧的结果被新的结果所覆盖。</p>
<p>如果不明确调用<code>allowedLateness</code>，默认的允许延迟的参数是0。如果对一个Processing Time下的程序使用<code>allowedLateness</code>，将引发异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ProcessWindowFunction接收的泛型参数分别为：[输入类型、输出类型、Key、Window]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class AllowedLatenessFunction extends ProcessWindowFunction[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (String, Long, Int), (String, String, Int, String), String, TimeWindow] {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  override def process(key: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       context: Context,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       elements: Iterable[(String, Long, Int)],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       out: Collector[(String, String, Int, String)]): Unit = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是否被迟到数据更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val isUpdated = context.windowState.getState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      new ValueStateDescriptor[Boolean](&quot;isUpdated&quot;, Types.of[Boolean])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val count = elements.size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isUpdated.value() == false) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 第一次使用process函数时， Boolean默认初始化为false，因此窗口函数第一次被调用时会进入这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.collect((key, format.format(Calendar.getInstance().getTime), count, &quot;first&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      isUpdated.update(true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 之后isUpdated被置为true，窗口函数因迟到数据被调用时会进入这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.collect((key, format.format(Calendar.getInstance().getTime), count, &quot;updated&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 数据流有三个字段：（key, 时间戳, 数值）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val input: DataStream[(String, Long, Int)] = ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val allowedLatenessStream = input.keyBy(item =&gt; item._1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .timeWindow(Time.seconds(5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .allowedLateness(Time.seconds(5))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .process(new AllowedLatenessFunction)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Flink/Flink WaterMark详解.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/Flink/Flink SQL JOIN原理"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Flink SQL JOIN原理</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/Flink/FlinkCheckpoint源码分析"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">FlinkCheckpoint源码分析</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#watermark的作用" class="table-of-contents__link toc-highlight">Watermark的作用</a><ul><li><a href="#概述" class="table-of-contents__link toc-highlight">概述</a></li><li><a href="#水位线图解" class="table-of-contents__link toc-highlight">水位线图解</a></li><li><a href="#水位线的传播" class="table-of-contents__link toc-highlight">水位线的传播</a></li><li><a href="#水位线的生成方式" class="table-of-contents__link toc-highlight">水位线的生成方式</a></li><li><a href="#迟到的数据" class="table-of-contents__link toc-highlight">迟到的数据</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>