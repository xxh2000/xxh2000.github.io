"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8244],{4506:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>p});var a=t(4848),o=t(8453);const s={},i=void 0,r={id:"Flink/FlinkCheckpoint\u6e90\u7801\u5206\u6790",title:"FlinkCheckpoint\u6e90\u7801\u5206\u6790",description:"Checkpoint\u8fc7\u7a0b",source:"@site/docs/Flink/FlinkCheckpoint\u6e90\u7801\u5206\u6790.md",sourceDirName:"Flink",slug:"/Flink/FlinkCheckpoint\u6e90\u7801\u5206\u6790",permalink:"/docs/Flink/FlinkCheckpoint\u6e90\u7801\u5206\u6790",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Flink/FlinkCheckpoint\u6e90\u7801\u5206\u6790.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Flink WaterMark\u8be6\u89e3",permalink:"/docs/Flink/Flink WaterMark\u8be6\u89e3"},next:{title:"Flink\u5b9e\u8df5",permalink:"/docs/Flink/Flink\u5b9e\u8df5"}},c={},p=[{value:"<strong>Checkpoint\u8fc7\u7a0b</strong>",id:"checkpoint\u8fc7\u7a0b",level:3},{value:"<strong>\u9884\u68c0\u67e5</strong>",id:"\u9884\u68c0\u67e5",level:3},{value:"<strong>\u5e7f\u64adBarrier</strong>",id:"\u5e7f\u64adbarrier",level:3},{value:"<strong>\u8fdb\u884c\u5feb\u7167</strong>",id:"\u8fdb\u884c\u5feb\u7167",level:3},{value:"<strong>Checkpoint \u7684\u786e\u8ba4</strong>",id:"checkpoint-\u7684\u786e\u8ba4",level:3},{value:"<strong>\u786e\u8ba4\u5b8c\u6210</strong>",id:"\u786e\u8ba4\u5b8c\u6210",level:3}];function l(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h3,{id:"checkpoint\u8fc7\u7a0b",children:(0,a.jsx)(n.strong,{children:"Checkpoint\u8fc7\u7a0b"})}),"\n",(0,a.jsx)(n.p,{children:"\u6211\u4eec\u90fd\u77e5\u9053checkpoint\u7684\u5468\u671f\u6027\u89e6\u53d1\u662f\u7531jobmanager\u4e2d\u7684\u4e00\u4e2a\u53eb\u505aCheckpointCoordinator\u89d2\u8272\u53d1\u8d77\u7684\uff0c\u5177\u4f53\u6267\u884c\u5728CheckpointCoordinator.triggerCheckpoint\u4e2d\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u4ee3\u7801\u903b\u8f91\u5f88\u957f\uff0c\u6982\u62ec\u4e00\u4e0b\u4e3b\u8981\u5305\u62ec\u4ee5\u4e0b\u8fc7\u7a0b\u3002"}),"\n",(0,a.jsx)(n.h3,{id:"\u9884\u68c0\u67e5",children:(0,a.jsx)(n.strong,{children:"\u9884\u68c0\u67e5"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u662f\u5426\u9700\u8981\u5f3a\u5236\u8fdb\u884c checkpoint"}),"\n",(0,a.jsx)(n.li,{children:"\u5f53\u524d\u6b63\u5728\u6392\u961f\u7684\u5e76\u53d1 checkpoint \u7684\u6570\u76ee\u662f\u5426\u8d85\u8fc7\u9608\u503c"}),"\n",(0,a.jsx)(n.li,{children:"\u8ddd\u79bb\u4e0a\u4e00\u6b21\u6210\u529f checkpoint \u7684\u95f4\u9694\u65f6\u95f4\u662f\u5426\u8fc7\u5c0f"}),"\n",(0,a.jsx)(n.li,{children:"\u5982\u679c\u4e0a\u8ff0\u6761\u4ef6\u4e0d\u6ee1\u8db3\u5219\u4e0d\u4f1a\u8fdb\u884c\u8fd9\u6b21checkpoint\u3002"}),"\n",(0,a.jsx)(n.li,{children:"\u68c0\u67e5\u9700\u8981\u89e6\u53d1\u7684task\u662f\u5426\u90fd\u662frunning\u72b6\u6001\uff0c\u5426\u5219\u653e\u5f03\u3002\u4e4b\u524d\u8e29\u8fc7\u5751\uff0c\u8bf7\u89c1\u8bb0\u4e00\u6b21flink\u4e0d\u505acheckpoint\u7684\u95ee\u9898\u3002"}),"\n",(0,a.jsx)(n.li,{children:"\u68c0\u67e5\u6240\u6709\u9700\u8981ack checkpoint\u5b8c\u6210\u7684task\u662f\u5426\u90fd\u662frunning\u72b6\u6001\u3002\u5426\u5219\u653e\u5f03\u3002\u4e0a\u9762\u7684\u68c0\u67e5\u90fd\u901a\u8fc7\u4e4b\u540e\u5c31\u53ef\u4ee5\u505acheckpoint\u5566\u3002"}),"\n",(0,a.jsx)(n.li,{children:"\u751f\u6210\u552f\u4e00\u81ea\u589e\u7684checkpointID\u3002"}),"\n",(0,a.jsx)(n.li,{children:"\u521d\u59cb\u5316CheckpointStorageLocation\uff0c\u7528\u4e8e\u5b58\u50a8\u8fd9\u6b21checkpoint\u5feb\u7167\u7684\u8def\u5f84\uff0c\u4e0d\u540c\u7684backend\u6709\u533a\u522b\u3002"}),"\n",(0,a.jsx)(n.li,{children:"\u751f\u6210 PendingCheckpoint\uff0c\u8fd9\u8868\u793a\u4e00\u4e2a\u5904\u4e8e\u4e2d\u95f4\u72b6\u6001\u7684 checkpoint\uff0c\u5e76\u4fdd\u5b58\u5728 checkpointId -> PendingCheckpoint \u8fd9\u6837\u7684\u6620\u5c04\u5173\u7cfb\u4e2d\u3002"}),"\n",(0,a.jsx)(n.li,{children:"\u6ce8\u518c\u4e00\u4e2a\u8c03\u5ea6\u4efb\u52a1\uff0c\u5728 checkpoint \u8d85\u65f6\u540e\u53d6\u6d88\u6b64\u6b21 checkpoint\uff0c\u5e76\u91cd\u65b0\u89e6\u53d1\u4e00\u6b21\u65b0\u7684 checkpoint"}),"\n",(0,a.jsx)(n.li,{children:"\u8c03\u7528 Execution.triggerCheckpoint() \u65b9\u6cd5\u5411\u6240\u6709\u9700\u8981 trigger \u7684 task \u53d1\u8d77 checkpoint \u8bf7\u6c42"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"for (Execution execution: executions) {\n                if (props.isSynchronous()) {\n                    execution.triggerSynchronousSavepoint(checkpointID, timestamp, checkpointOptions, advanceToEndOfTime);\n                } else {\n                    execution.triggerCheckpoint(checkpointID, timestamp, checkpointOptions);\n                }\n            }\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u6700\u7ec8\u901a\u8fc7 RPC \u8c03\u7528 TaskExecutorGateway.triggerCheckpoint\uff0c\u5373\u8bf7\u6c42\u6267\u884c TaskExecutor.triggerCheckpoin()\u3002\u56e0\u4e3a\u4e00\u4e2a TaskExecutor \u4e2d\u53ef\u80fd\u6709\u591a\u4e2a Task \u6b63\u5728\u8fd0\u884c\uff0c\u56e0\u800c\u8981\u6839\u636e\u89e6\u53d1 checkpoint \u7684 ExecutionAttemptID \u627e\u5230\u5bf9\u5e94\u7684 Task\uff0c\u7136\u540e\u8c03\u7528 Task.triggerCheckpointBarrier() \u65b9\u6cd5"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'private void triggerCheckpointHelper(long checkpointId, long timestamp, CheckpointOptions checkpointOptions, boolean advanceToEndOfEventTime) {\n\n        final CheckpointType checkpointType = checkpointOptions.getCheckpointType();\n        if (advanceToEndOfEventTime && !(checkpointType.isSynchronous() && checkpointType.isSavepoint())) {\n            throw new IllegalArgumentException("Only synchronous savepoints are allowed to advance the watermark to MAX.");\n        }\n\n        final LogicalSlot slot = assignedResource;\n\n        if (slot != null) {\n            final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();\n\n            taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions, advanceToEndOfEventTime);\n        } else {\n            LOG.debug("The execution has no slot assigned. This indicates that the execution is no longer running.");\n        }\n    }\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'@Override\n    public CompletableFuture<Acknowledge> triggerCheckpoint(\n            ExecutionAttemptID executionAttemptID,\n            long checkpointId,\n            long checkpointTimestamp,\n            CheckpointOptions checkpointOptions,\n            boolean advanceToEndOfEventTime) {\n        log.debug("Trigger checkpoint {}@{} for {}.", checkpointId, checkpointTimestamp, executionAttemptID);\n\n        final CheckpointType checkpointType = checkpointOptions.getCheckpointType();\n        if (advanceToEndOfEventTime && !(checkpointType.isSynchronous() && checkpointType.isSavepoint())) {\n            throw new IllegalArgumentException("Only synchronous savepoints are allowed to advance the watermark to MAX.");\n        }\n\n        final Task task = taskSlotTable.getTask(executionAttemptID);\n\n        if (task != null) {\n            task.triggerCheckpointBarrier(checkpointId, checkpointTimestamp, checkpointOptions, advanceToEndOfEventTime);\n\n            return CompletableFuture.completedFuture(Acknowledge.get());\n        } else {\n            final String message = "TaskManager received a checkpoint request for unknown task " + executionAttemptID + \'.\';\n\n            log.debug(message);\n            return FutureUtils.completedExceptionally(new CheckpointException(message, CheckpointFailureReason.TASK_CHECKPOINT_FAILURE));\n        }\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"Task \u6267\u884c checkpoint \u7684\u771f\u6b63\u903b\u8f91\u88ab\u5c01\u88c5\u5728 AbstractInvokable.triggerCheckpointAsync(...) \u4e2d\uff0c"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'public void triggerCheckpointBarrier(\n            final long checkpointID,\n            final long checkpointTimestamp,\n            final CheckpointOptions checkpointOptions,\n            final boolean advanceToEndOfEventTime) {\n\n        final AbstractInvokable invokable = this.invokable;\n        final CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointID, checkpointTimestamp);\n\n        if (executionState == ExecutionState.RUNNING && invokable != null) {\n            try {\n                invokable.triggerCheckpointAsync(checkpointMetaData, checkpointOptions, advanceToEndOfEventTime);\n            }\n            catch (RejectedExecutionException ex) {\n                // This may happen if the mailbox is closed. It means that the task is shutting down, so we just ignore it.\n                LOG.debug(\n                    "Triggering checkpoint {} for {} ({}) was rejected by the mailbox",\n                    checkpointID, taskNameWithSubtask, executionId);\n            }\n            catch (Throwable t) {\n                if (getExecutionState() == ExecutionState.RUNNING) {\n                    failExternally(new Exception(\n                        "Error while triggering checkpoint " + checkpointID + " for " +\n                            taskNameWithSubtask, t));\n                } else {\n                    LOG.debug("Encountered error while triggering checkpoint {} for " +\n                        "{} ({}) while being not in state running.", checkpointID,\n                        taskNameWithSubtask, executionId, t);\n                }\n            }\n        }\n        else {\n            LOG.debug("Declining checkpoint request for non-running task {} ({}).", taskNameWithSubtask, executionId);\n\n            // send back a message that we did not do the checkpoint\n            checkpointResponder.declineCheckpoint(jobId, executionId, checkpointID,\n                    new CheckpointException("Task name with subtask : " + taskNameWithSubtask, CheckpointFailureReason.CHECKPOINT_DECLINED_TASK_NOT_READY));\n        }\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"triggerCheckpointAsync\u65b9\u6cd5\u5206\u522b\u88abSourceStreamTask\u548c\u666e\u901aStreamTask\u8986\u76d6\uff0c\u4e3b\u8981\u903b\u8f91\u8fd8\u662f\u5728StreamTask\u4e2d"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"private boolean performCheckpoint(\n            CheckpointMetaData checkpointMetaData,\n            CheckpointOptions checkpointOptions,\n            CheckpointMetrics checkpointMetrics,\n            boolean advanceToEndOfTime) throws Exception {\n\n        LOG.debug(\"Starting checkpoint ({}) {} on task {}\",\n            checkpointMetaData.getCheckpointId(), checkpointOptions.getCheckpointType(), getName());\n\n        final long checkpointId = checkpointMetaData.getCheckpointId();\n\n        if (isRunning) {\n            actionExecutor.runThrowing(() -> {\n\n                if (checkpointOptions.getCheckpointType().isSynchronous()) {\n                    setSynchronousSavepointId(checkpointId);\n\n                    if (advanceToEndOfTime) {\n                        advanceToEndOfEventTime();\n                    }\n                }\n\n                // All of the following steps happen as an atomic step from the perspective of barriers and\n                // records/watermarks/timers/callbacks.\n                // We generally try to emit the checkpoint barrier as soon as possible to not affect downstream\n                // checkpoint alignments\n\n                // Step (1): Prepare the checkpoint, allow operators to do some pre-barrier work.\n                //           The pre-barrier work should be nothing or minimal in the common case.\n                operatorChain.prepareSnapshotPreBarrier(checkpointId);\n\n                // Step (2): Send the checkpoint barrier downstream\n                operatorChain.broadcastCheckpointBarrier(\n                        checkpointId,\n                        checkpointMetaData.getTimestamp(),\n                        checkpointOptions);\n\n                // Step (3): Take the state snapshot. This should be largely asynchronous, to not\n                //           impact progress of the streaming topology\n                checkpointState(checkpointMetaData, checkpointOptions, checkpointMetrics);\n\n            });\n\n            return true;\n        } else {\n            actionExecutor.runThrowing(() -> {\n                // we cannot perform our checkpoint - let the downstream operators know that they\n                // should not wait for any input from this operator\n\n                // we cannot broadcast the cancellation markers on the 'operator chain', because it may not\n                // yet be created\n                final CancelCheckpointMarker message = new CancelCheckpointMarker(checkpointMetaData.getCheckpointId());\n                recordWriter.broadcastEvent(message);\n            });\n\n            return false;\n        }\n    }\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u4e3b\u8981\u505a\u4e09\u4ef6\u4e8b\uff1a1\uff09checkpoint\u7684\u51c6\u5907\u64cd\u4f5c\uff0c\u8fd9\u91cc\u901a\u5e38\u4e0d\u8fdb\u884c\u592a\u591a\u64cd\u4f5c\uff1b2\uff09\u53d1\u9001 CheckpointBarrier\uff1b3\uff09\u5b58\u50a8\u68c0\u67e5\u70b9\u5feb\u7167\u3002"}),"\n",(0,a.jsx)(n.h3,{id:"\u5e7f\u64adbarrier",children:(0,a.jsx)(n.strong,{children:"\u5e7f\u64adBarrier"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"public void broadcastCheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) throws IOException {\n        CheckpointBarrier barrier = new CheckpointBarrier(id, timestamp, checkpointOptions);\n        for (RecordWriterOutput<?> streamOutput : streamOutputs) {\n            streamOutput.broadcastEvent(barrier);\n        }\n    }\n"})}),"\n",(0,a.jsx)(n.h3,{id:"\u8fdb\u884c\u5feb\u7167",children:(0,a.jsx)(n.strong,{children:"\u8fdb\u884c\u5feb\u7167"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"private void checkpointState(\n            CheckpointMetaData checkpointMetaData,\n            CheckpointOptions checkpointOptions,\n            CheckpointMetrics checkpointMetrics) throws Exception {\n        //checkpoint\u7684\u5b58\u50a8\u5730\u5740\u53ca\u5143\u6570\u636e\u4fe1\u606f\n        CheckpointStreamFactory storage = checkpointStorage.resolveCheckpointStorageLocation(\n                checkpointMetaData.getCheckpointId(),\n                checkpointOptions.getTargetLocation());\n        //\u5c06checkpoint\u7684\u8fc7\u7a0b\u5c01\u88c5\u4e3aCheckpointingOperation\u5bf9\u8c61\n        CheckpointingOperation checkpointingOperation = new CheckpointingOperation(\n            this,\n            checkpointMetaData,\n            checkpointOptions,\n            storage,\n            checkpointMetrics);\n\n        checkpointingOperation.executeCheckpointing();\n    }\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u6bcf\u4e00\u4e2a\u7b97\u5b50\u7684\u5feb\u7167\u88ab\u62bd\u8c61\u4e3a OperatorSnapshotFutures\uff0c\u5305\u542b\u4e86 operator state \u548c keyed state \u7684\u5feb\u7167\u7ed3\u679c\uff1a"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"public class OperatorSnapshotFutures {\n\n    @Nonnull\n    private RunnableFuture<SnapshotResult<KeyedStateHandle>> keyedStateManagedFuture;\n\n    @Nonnull\n    private RunnableFuture<SnapshotResult<KeyedStateHandle>> keyedStateRawFuture;\n\n    @Nonnull\n    private RunnableFuture<SnapshotResult<OperatorStateHandle>> operatorStateManagedFuture;\n\n    @Nonnull\n    private RunnableFuture<SnapshotResult<OperatorStateHandle>> operatorStateRawFuture;\n    }\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u7531\u4e8e\u6bcf\u4e00\u4e2a StreamTask \u53ef\u80fd\u5305\u542b\u591a\u4e2a\u7b97\u5b50\uff0c\u56e0\u800c\u5185\u90e8\u4f7f\u7528\u4e00\u4e2a Map \u7ef4\u62a4 OperatorID -> OperatorSnapshotFutures \u7684\u5173\u7cfb\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"        private final Map<OperatorID, OperatorSnapshotFutures> operatorSnapshotsInProgress;\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u5feb\u7167\u7684\u8fc7\u7a0b\u5206\u540c\u6b65\u548c\u5f02\u6b65\u4e24\u4e2a\u90e8\u5206"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'public void executeCheckpointing() throws Exception {\n            startSyncPartNano = System.nanoTime();\n\n            try {\n            //\u540c\u6b65\n                for (StreamOperator<?> op : allOperators) {\n                    checkpointStreamOperator(op);\n                }\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug("Finished synchronous checkpoints for checkpoint {} on task {}",\n                        checkpointMetaData.getCheckpointId(), owner.getName());\n                }\n\n                startAsyncPartNano = System.nanoTime();\n\n                checkpointMetrics.setSyncDurationMillis((startAsyncPartNano - startSyncPartNano) / 1_000_000);\n\n                // we are transferring ownership over snapshotInProgressList for cleanup to the thread, active on submit\n                //\u5f02\u6b65\n                // checkpoint \u53ef\u4ee5\u914d\u7f6e\u6210\u540c\u6b65\u6267\u884c\uff0c\u4e5f\u53ef\u4ee5\u914d\u7f6e\u6210\u5f02\u6b65\u6267\u884c\u7684\n                // \u5982\u679c\u662f\u540c\u6b65\u6267\u884c\u7684\uff0c\u5728\u8fd9\u91cc\u5b9e\u9645\u4e0a\u6240\u6709\u7684 runnable future \u90fd\u662f\u5df2\u7ecf\u5b8c\u6210\u7684\u72b6\u6001\n                AsyncCheckpointRunnable asyncCheckpointRunnable = new AsyncCheckpointRunnable(\n                    owner,\n                    operatorSnapshotsInProgress,\n                    checkpointMetaData,\n                    checkpointMetrics,\n                    startAsyncPartNano);\n\n                owner.cancelables.registerCloseable(asyncCheckpointRunnable);\n                owner.asyncOperationsThreadPool.execute(asyncCheckpointRunnable);\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug("{} - finished synchronous part of checkpoint {}. " +\n                            "Alignment duration: {} ms, snapshot duration {} ms",\n                        owner.getName(), checkpointMetaData.getCheckpointId(),\n                        checkpointMetrics.getAlignmentDurationNanos() / 1_000_000,\n                        checkpointMetrics.getSyncDurationMillis());\n                }\n            } catch (Exception ex) {\n                // Cleanup to release resources\n                for (OperatorSnapshotFutures operatorSnapshotResult : operatorSnapshotsInProgress.values()) {\n                    if (null != operatorSnapshotResult) {\n                        try {\n                            operatorSnapshotResult.cancel();\n                        } catch (Exception e) {\n                            LOG.warn("Could not properly cancel an operator snapshot result.", e);\n                        }\n                    }\n                }\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug("{} - did NOT finish synchronous part of checkpoint {}. " +\n                            "Alignment duration: {} ms, snapshot duration {} ms",\n                        owner.getName(), checkpointMetaData.getCheckpointId(),\n                        checkpointMetrics.getAlignmentDurationNanos() / 1_000_000,\n                        checkpointMetrics.getSyncDurationMillis());\n                }\n\n                if (checkpointOptions.getCheckpointType().isSynchronous()) {\n                    // in the case of a synchronous checkpoint, we always rethrow the exception,\n                    // so that the task fails.\n                    // this is because the intention is always to stop the job after this checkpointing\n                    // operation, and without the failure, the task would go back to normal execution.\n                    throw ex;\n                } else {\n                    owner.getEnvironment().declineCheckpoint(checkpointMetaData.getCheckpointId(), ex);\n                }\n            }\n        }\n'})}),"\n",(0,a.jsx)(n.p,{children:"\u5728\u540c\u6b65\u6267\u884c\u9636\u6bb5\uff0c\u4f1a\u4f9d\u6b21\u8c03\u7528\u6bcf\u4e00\u4e2a\u7b97\u5b50\u7684 StreamOperator.snapshotState\uff0c\u8fd4\u56de\u7ed3\u679c\u662f\u4e00\u4e2a runnable future\u3002\u6839\u636e checkpoint \u914d\u7f6e\u6210\u540c\u6b65\u6a21\u5f0f\u548c\u5f02\u6b65\u6a21\u5f0f\u7684\u533a\u522b\uff0c\u8fd9\u4e2a future \u53ef\u80fd\u5904\u4e8e\u5b8c\u6210\u72b6\u6001\uff0c\u4e5f\u53ef\u80fd\u5904\u4e8e\u672a\u5b8c\u6210\u72b6\u6001\uff1a"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"private void checkpointStreamOperator(StreamOperator<?> op) throws Exception {\n            if (null != op) {\n//\u540c\u6b65\u8fc7\u7a0b\u8c03\u7528\u7b97\u5b50\u7684snapshotState\u65b9\u6cd5\uff0c\u8fd4\u56deOperatorSnapshotFutures\u53ef\u80fd\u5df2\u5b8c\u6210\u6216\u672a\u5b8c\u6210\n                OperatorSnapshotFutures snapshotInProgress = op.snapshotState(\n                        checkpointMetaData.getCheckpointId(),\n                        checkpointMetaData.getTimestamp(),\n                        checkpointOptions,\n                        storageLocation);\n                operatorSnapshotsInProgress.put(op.getOperatorID(), snapshotInProgress);\n            }\n        }\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u8be6\u7ec6\u8fc7\u7a0b\u5728AbstractStreamOperator#snapshotState"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'public final OperatorSnapshotFutures snapshotState(long checkpointId, long timestamp, CheckpointOptions checkpointOptions,\n            CheckpointStreamFactory factory) throws Exception {\n\n        KeyGroupRange keyGroupRange = null != keyedStateBackend ?\n                keyedStateBackend.getKeyGroupRange() : KeyGroupRange.EMPTY_KEY_GROUP_RANGE;\n\n        OperatorSnapshotFutures snapshotInProgress = new OperatorSnapshotFutures();\n\n        StateSnapshotContextSynchronousImpl snapshotContext = new StateSnapshotContextSynchronousImpl(\n            checkpointId,\n            timestamp,\n            factory,\n            keyGroupRange,\n            getContainingTask().getCancelables());\n\n        try {\n            //\u5bf9\u72b6\u6001\u8fdb\u884c\u5feb\u7167\uff0c\u5305\u62ecKeyedState\u548cOperatorState\n            snapshotState(snapshotContext);\n\n            snapshotInProgress.setKeyedStateRawFuture(snapshotContext.getKeyedStateStreamFuture());\n            snapshotInProgress.setOperatorStateRawFuture(snapshotContext.getOperatorStateStreamFuture());\n\n            //\u5199\u5165operatorState\u5feb\u7167\n            if (null != operatorStateBackend) {\n                snapshotInProgress.setOperatorStateManagedFuture(\n                    operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));\n            }\n            //\u5199\u5165keyedState\u5feb\u7167\n            if (null != keyedStateBackend) {\n                snapshotInProgress.setKeyedStateManagedFuture(\n                    keyedStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));\n            }\n        } catch (Exception snapshotException) {\n            try {\n                snapshotInProgress.cancel();\n            } catch (Exception e) {\n                snapshotException.addSuppressed(e);\n            }\n\n            String snapshotFailMessage = "Could not complete snapshot " + checkpointId + " for operator " +\n                getOperatorName() + ".";\n\n            if (!getContainingTask().isCanceled()) {\n                LOG.info(snapshotFailMessage, snapshotException);\n            }\n            try {\n                snapshotContext.closeExceptionally();\n            } catch (IOException e) {\n                snapshotException.addSuppressed(e);\n            }\n            throw new CheckpointException(snapshotFailMessage, CheckpointFailureReason.CHECKPOINT_DECLINED, snapshotException);\n        }\n\n        return snapshotInProgress;\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"\u6211\u4eec\u77e5\u9053state\u8fd8\u5206\u4e3araw state\uff08\u539f\u751fstate\uff09\u548cmanaged state\uff08flink\u7ba1\u7406\u7684state\uff09\uff0ctimer\u5b9a\u65f6\u5668\u5c5e\u4e8eraw state\uff0c\u4e5f\u9700\u8981\u5199\u5230snapshot\u4e2d\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'/**\n     * Stream operators with state, which want to participate in a snapshot need to override this hook method.\n     *\n     * @param context context that provides information and means required for taking a snapshot\n     */\n    public void snapshotState(StateSnapshotContext context) throws Exception {\n        final KeyedStateBackend<?> keyedStateBackend = getKeyedStateBackend();\n        //TODO all of this can be removed once heap-based timers are integrated with RocksDB incremental snapshots\n        // \u6240\u6709\u7684 timer \u90fd\u4f5c\u4e3a raw keyed state \u5199\u5165\n        if (keyedStateBackend instanceof AbstractKeyedStateBackend &&\n            ((AbstractKeyedStateBackend<?>) keyedStateBackend).requiresLegacySynchronousTimerSnapshots()) {\n\n            KeyedStateCheckpointOutputStream out;\n\n            try {\n                out = context.getRawKeyedOperatorStateOutput();\n            } catch (Exception exception) {\n                throw new Exception("Could not open raw keyed operator state stream for " +\n                    getOperatorName() + \'.\', exception);\n            }\n\n            try {\n                KeyGroupsList allKeyGroups = out.getKeyGroupList();\n                for (int keyGroupIdx : allKeyGroups) {\n                    out.startNewKeyGroup(keyGroupIdx);\n\n                    timeServiceManager.snapshotStateForKeyGroup(\n                        new DataOutputViewStreamWrapper(out), keyGroupIdx);\n                }\n            } catch (Exception exception) {\n                throw new Exception("Could not write timer service of " + getOperatorName() +\n                    " to checkpoint state stream.", exception);\n            } finally {\n                try {\n                    out.close();\n                } catch (Exception closeException) {\n                    LOG.warn("Could not close raw keyed operator state stream for {}. This " +\n                        "might have prevented deleting some state data.", getOperatorName(), closeException);\n                }\n            }\n        }\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"\u4e0a\u9762\u662fAbstractStreamOperator\u4e2d\u7684snapshotState\u505a\u7684\u64cd\u4f5c\uff0c\u8fd8\u6709\u4e2a\u5b50\u7c7bAbstractUdfStreamOperator"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"public void snapshotState(StateSnapshotContext context) throws Exception {\n        //\u5148\u8c03\u7528\u7236\u7c7b\u65b9\u6cd5\uff0c\u5199\u5165timer\n        super.snapshotState(context);\n        StreamingFunctionUtils.snapshotFunctionState(context, getOperatorStateBackend(), userFunction);\n    }\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'public static void snapshotFunctionState(\n            StateSnapshotContext context,\n            OperatorStateBackend backend,\n            Function userFunction) throws Exception {\n\n        Preconditions.checkNotNull(context);\n        Preconditions.checkNotNull(backend);\n\n        while (true) {\n\n            if (trySnapshotFunctionState(context, backend, userFunction)) {\n                break;\n            }\n\n            // inspect if the user function is wrapped, then unwrap and try again if we can snapshot the inner function\n            if (userFunction instanceof WrappingFunction) {\n                userFunction = ((WrappingFunction<?>) userFunction).getWrappedFunction();\n            } else {\n                break;\n            }\n        }\n    }\n\n\nprivate static boolean trySnapshotFunctionState(\n            StateSnapshotContext context,\n            OperatorStateBackend backend,\n            Function userFunction) throws Exception {\n        //\u5982\u679c\u7528\u6237\u51fd\u6570\u5b9e\u73b0\u4e86CheckpointedFunction\u63a5\u53e3\uff0c\u5219\u8c03\u7528udf\u4e2d\u7684snapshotState\u65b9\u6cd5\u8fdb\u884c\u5feb\u7167\n        if (userFunction instanceof CheckpointedFunction) {\n            ((CheckpointedFunction) userFunction).snapshotState(context);\n\n            return true;\n        }\n        // \u5982\u679c\u7528\u6237\u51fd\u6570\u5b9e\u73b0\u4e86 ListCheckpointed\n        if (userFunction instanceof ListCheckpointed) {\n        //\u5148\u8c03\u7528 snapshotState \u65b9\u6cd5\u83b7\u53d6\u5f53\u524d\u72b6\u6001\n            @SuppressWarnings("unchecked")\n            List<Serializable> partitionableState = ((ListCheckpointed<Serializable>) userFunction).\n                    snapshotState(context.getCheckpointId(), context.getCheckpointTimestamp());\n            //\u83b7\u53d6\u72b6\u6001\u540e\u7aef\u5b58\u50a8\u5f15\u7528\n            ListState<Serializable> listState = backend.\n                    getSerializableListState(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME);\n            //\u6e05\u7a7a\n            listState.clear();\n            //\u5f53\u524d\u72b6\u6001\u5199\u5165\u72b6\u6001\u540e\u7aef\u5b58\u50a8\n            if (null != partitionableState) {\n                try {\n                    for (Serializable statePartition : partitionableState) {\n                        listState.add(statePartition);\n                    }\n                } catch (Exception e) {\n                    listState.clear();\n\n                    throw new Exception("Could not write partitionable state to operator " +\n                        "state backend.", e);\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"\u5230\u8fd9\u91cc\u6211\u4eec\u77e5\u9053\u4e86checkpoint\u8fc7\u7a0b\u4e2d\u5982\u4f55\u8c03\u7528\u5230\u6211\u4eec\u81ea\u5df1\u5b9e\u73b0\u7684\u5feb\u7167\u65b9\u6cd5\u3002\u518d\u770b\u4e0bflink\u7ba1\u7406\u7684\u72b6\u6001\u662f\u5982\u4f55\u5199\u5165\u5feb\u7167\u7684\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"            if (null != operatorStateBackend) {\n                snapshotInProgress.setOperatorStateManagedFuture(\n                    operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));\n            }\n\n            if (null != keyedStateBackend) {\n                snapshotInProgress.setKeyedStateManagedFuture(\n                    keyedStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));\n            }\n"})}),"\n",(0,a.jsx)(n.p,{children:"\u9996\u5148\u6765\u770b\u770b operator state\u3002DefaultOperatorStateBackend \u5c06\u5b9e\u9645\u7684\u5de5\u4f5c\u4ea4\u7ed9 DefaultOperatorStateBackendSnapshotStrategy \u5b8c\u6210\u3002\u9996\u5148\uff0c\u4f1a\u4e3a\u5bf9\u5f53\u524d\u6ce8\u518c\u7684\u6240\u6709 operator state\uff08\u5305\u542b list state \u548c broadcast state\uff09\u505a\u6df1\u5ea6\u62f7\u8d1d\uff0c\u7136\u540e\u5c06\u5b9e\u9645\u7684\u5199\u5165\u64cd\u4f5c\u5c01\u88c5\u5728\u4e00\u4e2a\u5f02\u6b65\u7684 FutureTask \u4e2d\uff0c\u8fd9\u4e2a FutureTask \u7684\u4e3b\u8981\u4efb\u52a1\u5305\u62ec\uff1a1\uff09\u6253\u5f00\u8f93\u51fa\u6d41 2\uff09\u5199\u5165\u72b6\u6001\u5143\u6570\u636e\u4fe1\u606f 3\uff09\u5199\u5165\u72b6\u6001 4\uff09\u5173\u95ed\u8f93\u51fa\u6d41\uff0c\u83b7\u5f97\u72b6\u6001\u53e5\u67c4\u3002\u5982\u679c\u4e0d\u542f\u7528\u5f02\u6b65checkpoint\u6a21\u5f0f\uff0c\u90a3\u4e48\u8fd9\u4e2a FutureTask \u5728\u540c\u6b65\u9636\u6bb5\u5c31\u4f1a\u7acb\u523b\u6267\u884c\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(\n        final long checkpointId,\n        final long timestamp,\n        @Nonnull final CheckpointStreamFactory streamFactory,\n        @Nonnull final CheckpointOptions checkpointOptions) throws IOException {\n\n        if (registeredOperatorStates.isEmpty() && registeredBroadcastStates.isEmpty()) {\n            return DoneFuture.of(SnapshotResult.empty());\n        }\n\n        final Map<String, PartitionableListState<?>> registeredOperatorStatesDeepCopies =\n            new HashMap<>(registeredOperatorStates.size());\n        final Map<String, BackendWritableBroadcastState<?, ?>> registeredBroadcastStatesDeepCopies =\n            new HashMap<>(registeredBroadcastStates.size());\n\n        ClassLoader snapshotClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(userClassLoader);\n        try {\n            // eagerly create deep copies of the list and the broadcast states (if any)\n            // in the synchronous phase, so that we can use them in the async writing.\n            //\u83b7\u5f97\u5df2\u6ce8\u518c\u7684\u6240\u6709 list state \u548c broadcast state \u7684\u6df1\u62f7\u8d1d\n            if (!registeredOperatorStates.isEmpty()) {\n                for (Map.Entry<String, PartitionableListState<?>> entry : registeredOperatorStates.entrySet()) {\n                    PartitionableListState<?> listState = entry.getValue();\n                    if (null != listState) {\n                        listState = listState.deepCopy();\n                    }\n                    registeredOperatorStatesDeepCopies.put(entry.getKey(), listState);\n                }\n            }\n\n            if (!registeredBroadcastStates.isEmpty()) {\n                for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry : registeredBroadcastStates.entrySet()) {\n                    BackendWritableBroadcastState<?, ?> broadcastState = entry.getValue();\n                    if (null != broadcastState) {\n                        broadcastState = broadcastState.deepCopy();\n                    }\n                    registeredBroadcastStatesDeepCopies.put(entry.getKey(), broadcastState);\n                }\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(snapshotClassLoader);\n        }\n//\u5c06\u4e3b\u8981\u5199\u5165\u64cd\u4f5c\u5c01\u88c5\u4e3a\u4e00\u4e2a\u5f02\u6b65\u7684FutureTask\n        AsyncSnapshotCallable<SnapshotResult<OperatorStateHandle>> snapshotCallable =\n            new AsyncSnapshotCallable<SnapshotResult<OperatorStateHandle>>() {\n\n                @Override\n                protected SnapshotResult<OperatorStateHandle> callInternal() throws Exception {\n                    // \u521b\u5efa\u72b6\u6001\u8f93\u51fa\u6d41\n                    CheckpointStreamFactory.CheckpointStateOutputStream localOut =\n                        streamFactory.createCheckpointStateOutputStream(CheckpointedStateScope.EXCLUSIVE);\n                    snapshotCloseableRegistry.registerCloseable(localOut);\n                    // \u6536\u96c6\u5143\u6570\u636e\n                    // get the registered operator state infos ...\n                    List<StateMetaInfoSnapshot> operatorMetaInfoSnapshots =\n                        new ArrayList<>(registeredOperatorStatesDeepCopies.size());\n\n                    for (Map.Entry<String, PartitionableListState<?>> entry :\n                        registeredOperatorStatesDeepCopies.entrySet()) {\n                        operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());\n                    }\n                    // \u5199\u5165\u5143\u6570\u636e\n                    // ... get the registered broadcast operator state infos ...\n                    List<StateMetaInfoSnapshot> broadcastMetaInfoSnapshots =\n                        new ArrayList<>(registeredBroadcastStatesDeepCopies.size());\n\n                    for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry :\n                        registeredBroadcastStatesDeepCopies.entrySet()) {\n                        broadcastMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());\n                    }\n\n                    // ... write them all in the checkpoint stream ...\n                    DataOutputView dov = new DataOutputViewStreamWrapper(localOut);\n\n                    OperatorBackendSerializationProxy backendSerializationProxy =\n                        new OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots);\n\n                    backendSerializationProxy.write(dov);\n\n                    // ... and then go for the states ...\n                    // \u5199\u5165\u72b6\u6001\n                    // we put BOTH normal and broadcast state metadata here\n                    int initialMapCapacity =\n                        registeredOperatorStatesDeepCopies.size() + registeredBroadcastStatesDeepCopies.size();\n                    final Map<String, OperatorStateHandle.StateMetaInfo> writtenStatesMetaData =\n                        new HashMap<>(initialMapCapacity);\n\n                    for (Map.Entry<String, PartitionableListState<?>> entry :\n                        registeredOperatorStatesDeepCopies.entrySet()) {\n\n                        PartitionableListState<?> value = entry.getValue();\n                        long[] partitionOffsets = value.write(localOut);\n                        OperatorStateHandle.Mode mode = value.getStateMetaInfo().getAssignmentMode();\n                        writtenStatesMetaData.put(\n                            entry.getKey(),\n                            new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode));\n                    }\n\n                    // ... and the broadcast states themselves ...\n                    for (Map.Entry<String, BackendWritableBroadcastState<?, ?>> entry :\n                        registeredBroadcastStatesDeepCopies.entrySet()) {\n\n                        BackendWritableBroadcastState<?, ?> value = entry.getValue();\n                        long[] partitionOffsets = {value.write(localOut)};\n                        OperatorStateHandle.Mode mode = value.getStateMetaInfo().getAssignmentMode();\n                        writtenStatesMetaData.put(\n                            entry.getKey(),\n                            new OperatorStateHandle.StateMetaInfo(partitionOffsets, mode));\n                    }\n\n                    // ... and, finally, create the state handle.\n                    OperatorStateHandle retValue = null;\n\n                    if (snapshotCloseableRegistry.unregisterCloseable(localOut)) {\n                        //\u5173\u95ed\u8f93\u51fa\u6d41\uff0c\u83b7\u5f97\u72b6\u6001\u53e5\u67c4\uff0c\u540e\u9762\u53ef\u4ee5\u7528\u8fd9\u4e2a\u53e5\u67c4\u8bfb\u53d6\u72b6\u6001\n                        StreamStateHandle stateHandle = localOut.closeAndGetHandle();\n\n                        if (stateHandle != null) {\n                            retValue = new OperatorStreamStateHandle(writtenStatesMetaData, stateHandle);\n                        }\n\n                        return SnapshotResult.of(retValue);\n                    } else {\n                        throw new IOException("Stream was already unregistered.");\n                    }\n                }\n\n                @Override\n                protected void cleanupProvidedResources() {\n                    // nothing to do\n                }\n\n                @Override\n                protected void logAsyncSnapshotComplete(long startTime) {\n                    if (asynchronousSnapshots) {\n                        logAsyncCompleted(streamFactory, startTime);\n                    }\n                }\n            };\n\n        final FutureTask<SnapshotResult<OperatorStateHandle>> task =\n            snapshotCallable.toAsyncSnapshotFutureTask(closeStreamOnCancelRegistry);\n//\u5982\u679c\u4e0d\u662f\u5f02\u6b65 checkpoint \u90a3\u4e48\u5728\u8fd9\u91cc\u76f4\u63a5\u8fd0\u884c FutureTask\uff0c\u5373\u5728\u540c\u6b65\u9636\u6bb5\u5c31\u5b8c\u6210\u4e86\u72b6\u6001\u7684\u5199\u5165\n        if (!asynchronousSnapshots) {\n            task.run();\n        }\n\n        return task;\n    }\n'})}),"\n",(0,a.jsx)(n.p,{children:"keyed state \u5199\u5165\u7684\u57fa\u672c\u6d41\u7a0b\u4e0e\u6b64\u76f8\u4f3c\uff0c\u4f46\u7531\u4e8e keyed state \u5728\u5b58\u50a8\u65f6\u6709\u591a\u79cd\u5b9e\u73b0\uff0c\u5305\u62ec\u57fa\u4e8e\u5806\u5185\u5b58\u548c RocksDB \u7684\u4e0d\u540c\u5b9e\u73b0\uff0c\u6b64\u5916\u57fa\u4e8e RocksDB \u7684\u5b9e\u73b0\u8fd8\u5305\u62ec\u652f\u6301\u589e\u91cf checkpoint\uff0c\u56e0\u800c\u76f8\u6bd4\u4e8e operator state \u8981\u66f4\u590d\u6742\u4e00\u4e9b\u3002"}),"\n",(0,a.jsx)(n.p,{children:"\u81f3\u6b64\uff0c\u6211\u4eec\u4ecb\u7ecd\u4e86\u5feb\u7167\u64cd\u4f5c\u7684\u7b2c\u4e00\u4e2a\u9636\u6bb5\uff0c\u5373\u540c\u6b65\u6267\u884c\u7684\u9636\u6bb5\u3002\u5f02\u6b65\u6267\u884c\u9636\u6bb5\u88ab\u5c01\u88c5\u4e3a AsyncCheckpointRunnable\uff0c\u4e3b\u8981\u7684\u64cd\u4f5c\u5305\u62ec 1\uff09\u6267\u884c\u540c\u6b65\u9636\u6bb5\u521b\u5efa\u7684 FutureTask 2\uff09\u5b8c\u6210\u540e\u5411 CheckpointCoordinator \u53d1\u9001 Ack \u54cd\u5e94\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'protected static final class AsyncCheckpointRunnable implements Runnable, Closeable {\n        @Override\n        public void run() {\n            FileSystemSafetyNet.initializeSafetyNetForThread();\n            try {\n                TaskStateSnapshot jobManagerTaskOperatorSubtaskStates =\n                    new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n                TaskStateSnapshot localTaskOperatorSubtaskStates =\n                    new TaskStateSnapshot(operatorSnapshotsInProgress.size());\n\n                // \u5b8c\u6210\u6bcf\u4e00\u4e2a operator \u7684\u72b6\u6001\u5199\u5165\n                // \u5982\u679c\u662f\u540c\u6b65 checkpoint\uff0c\u90a3\u4e48\u5728\u6b64\u4e4b\u524d\u72b6\u6001\u5df2\u7ecf\u5199\u5165\u5b8c\u6210\n                // \u5982\u679c\u662f\u5f02\u6b65 checkpoint\uff0c\u90a3\u4e48\u5728\u8fd9\u91cc\u624d\u4f1a\u5199\u5165\u72b6\u6001\n                for (Map.Entry<OperatorID, OperatorSnapshotFutures> entry : operatorSnapshotsInProgress.entrySet()) {\n                    OperatorID operatorID = entry.getKey();\n                    OperatorSnapshotFutures snapshotInProgress = entry.getValue();\n                    // finalize the async part of all by executing all snapshot runnables\n                    OperatorSnapshotFinalizer finalizedSnapshots =\n                        new OperatorSnapshotFinalizer(snapshotInProgress);\n\n                    jobManagerTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n                        operatorID,\n                        finalizedSnapshots.getJobManagerOwnedState());\n\n                    localTaskOperatorSubtaskStates.putSubtaskStateByOperatorID(\n                        operatorID,\n                        finalizedSnapshots.getTaskLocalState());\n                }\n\n                final long asyncEndNanos = System.nanoTime();\n                final long asyncDurationMillis = (asyncEndNanos - asyncStartNanos) / 1_000_000L;\n\n                checkpointMetrics.setAsyncDurationMillis(asyncDurationMillis);\n\n                if (asyncCheckpointState.compareAndSet(CheckpointingOperation.AsyncCheckpointState.RUNNING,\n                    CheckpointingOperation.AsyncCheckpointState.COMPLETED)) {\n                    //\u62a5\u544a snapshot \u5b8c\u6210\n                    reportCompletedSnapshotStates(\n                        jobManagerTaskOperatorSubtaskStates,\n                        localTaskOperatorSubtaskStates,\n                        asyncDurationMillis);\n\n                } else {\n                    LOG.debug("{} - asynchronous part of checkpoint {} could not be completed because it was closed before.",\n                        owner.getName(),\n                        checkpointMetaData.getCheckpointId());\n                }\n            } catch (Exception e) {\n                handleExecutionException(e);\n            } finally {\n                owner.cancelables.unregisterCloseable(this);\n                FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();\n            }\n        }\n    }\n\n    private void reportCompletedSnapshotStates(\n            TaskStateSnapshot acknowledgedTaskStateSnapshot,\n            TaskStateSnapshot localTaskStateSnapshot,\n            long asyncDurationMillis) {\n            TaskStateManager taskStateManager = owner.getEnvironment().getTaskStateManager();\n            boolean hasAckState = acknowledgedTaskStateSnapshot.hasState();\n            boolean hasLocalState = localTaskStateSnapshot.hasState();\n            // we signal stateless tasks by reporting null, so that there are no attempts to assign empty state\n            // to stateless tasks on restore. This enables simple job modifications that only concern\n            // stateless without the need to assign them uids to match their (always empty) states.\n            taskStateManager.reportTaskStateSnapshots(\n                checkpointMetaData,\n                checkpointMetrics,\n                hasAckState ? acknowledgedTaskStateSnapshot : null,\n                hasLocalState ? localTaskStateSnapshot : null);\n        }\n}\n\npublic class TaskStateManagerImpl implements TaskStateManager {\n    @Override\n    public void reportTaskStateSnapshots(\n        @Nonnull CheckpointMetaData checkpointMetaData,\n        @Nonnull CheckpointMetrics checkpointMetrics,\n        @Nullable TaskStateSnapshot acknowledgedState,\n        @Nullable TaskStateSnapshot localState) {\n\n        long checkpointId = checkpointMetaData.getCheckpointId();\n\n        localStateStore.storeLocalState(checkpointId, localState);\n\n        //\u53d1\u9001 ACK \u54cd\u5e94\u7ed9 CheckpointCoordinator\n        checkpointResponder.acknowledgeCheckpoint(\n            jobId,\n            executionAttemptID,\n            checkpointId,\n            checkpointMetrics,\n            acknowledgedState);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"checkpoint-\u7684\u786e\u8ba4",children:(0,a.jsx)(n.strong,{children:"Checkpoint \u7684\u786e\u8ba4"})}),"\n",(0,a.jsx)(n.p,{children:"Task \u5bf9 checkpoint \u7684\u54cd\u5e94\u662f\u901a\u8fc7 CheckpointResponder \u63a5\u53e3\u5b8c\u6210\u7684\uff1a"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"public interface CheckpointResponder {\n\n    /**\n     * Acknowledges the given checkpoint.\n     */\n    void acknowledgeCheckpoint(\n        JobID jobID,\n        ExecutionAttemptID executionAttemptID,\n        long checkpointId,\n        CheckpointMetrics checkpointMetrics,\n        TaskStateSnapshot subtaskState);\n\n    /**\n     * Declines the given checkpoint.\n     */\n    void declineCheckpoint(\n        JobID jobID,\n        ExecutionAttemptID executionAttemptID,\n        long checkpointId,\n        Throwable cause);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"RpcCheckpointResponder \u4f5c\u4e3a CheckpointResponder \u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u4e3b\u8981\u662f\u901a\u8fc7 RPC \u8c03\u7528\u901a\u77e5 CheckpointCoordinatorGateway\uff0c\u5373\u901a\u77e5\u7ed9 JobMaster, JobMaster \u8c03\u7528 CheckpointCoordinator.receiveAcknowledgeMessage() \u548c CheckpointCoordinator.receiveDeclineMessage() \u8fdb\u884c\u5904\u7406\u3002"}),"\n",(0,a.jsx)(n.h3,{id:"\u786e\u8ba4\u5b8c\u6210",children:(0,a.jsx)(n.strong,{children:"\u786e\u8ba4\u5b8c\u6210"})}),"\n",(0,a.jsx)(n.p,{children:"\u5728\u4e00\u4e2a Task \u5b8c\u6210 checkpoint \u64cd\u4f5c\u540e\uff0cCheckpointCoordinator \u63a5\u6536\u5230 Ack \u54cd\u5e94\uff0c\u5bf9 Ack \u54cd\u5e94\u7684\u5904\u7406\u6d41\u7a0b\u4e3b\u8981\u5982\u4e0b\uff1a"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u6839\u636e Ack \u7684 checkpointID \u4ece Map pendingCheckpoints \u4e2d\u67e5\u627e\u5bf9\u5e94\u7684 PendingCheckpoint"}),"\n",(0,a.jsxs)(n.li,{children:["\u82e5\u5b58\u5728\u5bf9\u5e94\u7684 PendingCheckpoint","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u8fd9\u4e2a PendingCheckpoint \u6ca1\u6709\u88ab\u4e22\u5f03\uff0c\u8c03\u7528 PendingCheckpoint.acknowledgeTask \u65b9\u6cd5\u5904\u7406 Ack\uff0c\u6839\u636e\u5904\u7406\u7ed3\u679c\u7684\u4e0d\u540c\uff1a"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:"SUCCESS\uff1a\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u63a5\u53d7\u4e86\u6240\u6709\u9700\u8981\u54cd\u5e94\u7684 Ack\uff0c\u5982\u679c\u662f\uff0c\u5219\u8c03\u7528 completePendingCheckpoint \u5b8c\u6210\u6b64\u6b21 checkpoint"}),"\n",(0,a.jsx)(n.li,{children:"DUPLICATE\uff1aAck \u6d88\u606f\u91cd\u590d\u63a5\u6536\uff0c\u76f4\u63a5\u5ffd\u7565"}),"\n",(0,a.jsx)(n.li,{children:"UNKNOWN\uff1a\u672a\u77e5\u7684 Ack \u6d88\u606f\uff0c\u6e05\u7406\u4e0a\u62a5\u7684 Ack \u4e2d\u643a\u5e26\u7684\u72b6\u6001\u53e5\u67c4"}),"\n",(0,a.jsx)(n.li,{children:"DISCARD\uff1aCheckpoint \u5df2\u7ecf\u88ab discard\uff0c\u6e05\u7406\u4e0a\u62a5\u7684 Ack \u4e2d\u643a\u5e26\u7684\u72b6\u6001\u53e5\u67c4"}),"\n",(0,a.jsx)(n.li,{children:"\u8fd9\u4e2a PendingCheckpoint \u5df2\u7ecf\u88ab\u4e22\u5f03\uff0c\u629b\u51fa\u5f02\u5e38"}),"\n",(0,a.jsx)(n.li,{children:"\u82e5\u4e0d\u5b58\u5728\u5bf9\u5e94\u7684 PendingCheckpoint\uff0c\u5219\u6e05\u7406\u4e0a\u62a5\u7684 Ack \u4e2d\u643a\u5e26\u7684\u72b6\u6001\u53e5\u67c4\u76f8\u5e94\u4ee3\u7801\uff1a"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'class CheckpointCoordinator {\n    public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n        if (shutdown || message == null) {\n            return false;\n        }\n\n        if (!job.equals(message.getJob())) {\n            LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message);\n            return false;\n        }\n\n        final long checkpointId = message.getCheckpointId();\n\n        synchronized (lock) {\n            // we need to check inside the lock for being shutdown as well, otherwise we\n            // get races and invalid error log messages\n            if (shutdown) {\n                return false;\n            }\n\n            final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);\n\n            if (checkpoint != null && !checkpoint.isDiscarded()) {\n\n                switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                    case SUCCESS:\n                        LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",\n                            checkpointId, message.getTaskExecutionId(), message.getJob());\n\n                        if (checkpoint.isFullyAcknowledged()) {\n                            completePendingCheckpoint(checkpoint);\n                        }\n                        break;\n                    case DUPLICATE:\n                        LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",\n                            message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                        break;\n                    case UNKNOWN:\n                        LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +\n                                "because the task\'s execution attempt id was unknown. Discarding " +\n                                "the state handle to avoid lingering state.", message.getCheckpointId(),\n                            message.getTaskExecutionId(), message.getJob());\n\n                        discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n                        break;\n                    case DISCARDED:\n                        LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +\n                            "because the pending checkpoint had been discarded. Discarding the " +\n                                "state handle tp avoid lingering state.",\n                            message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n\n                        discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                }\n\n                return true;\n            }\n            else if (checkpoint != null) {\n                // this should not happen\n                throw new IllegalStateException(\n                        "Received message for discarded but non-removed checkpoint " + checkpointId);\n            }\n            else {\n                boolean wasPendingCheckpoint;\n                // message is for an unknown checkpoint, or comes too late (checkpoint disposed)\n                if (recentPendingCheckpoints.contains(checkpointId)) {\n                    wasPendingCheckpoint = true;\n                    LOG.warn("Received late message for now expired checkpoint attempt {} from " +\n                        "{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob());\n                }\n                else {\n                    LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",\n                        checkpointId, message.getTaskExecutionId(), message.getJob());\n                    wasPendingCheckpoint = false;\n                }\n\n                // try to discard the state so that we don\'t have lingering state lying around\n                discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n\n                return wasPendingCheckpoint;\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"\u5bf9\u4e8e\u4e00\u4e2a\u5df2\u7ecf\u89e6\u53d1\u4f46\u8fd8\u6ca1\u6709\u5b8c\u6210\u7684 checkpoint\uff0c\u5373 PendingCheckpoint\uff0c\u5b83\u662f\u5982\u4f55\u5904\u7406 Ack \u6d88\u606f\u7684\u5462\uff1f\u5728 PendingCheckpoint \u5185\u90e8\u7ef4\u62a4\u4e86\u4e24\u4e2a Map\uff0c\u5206\u522b\u662f\uff1a"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Map operatorStates; : \u5df2\u7ecf\u63a5\u6536\u5230 Ack \u7684\u7b97\u5b50\u7684\u72b6\u6001\u53e5\u67c4"}),"\n",(0,a.jsx)(n.li,{children:"Map notYetAcknowledgedTasks;: \u9700\u8981 Ack \u4f46\u8fd8\u6ca1\u6709\u63a5\u6536\u5230\u7684 Task"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"\u6bcf\u5f53\u63a5\u6536\u5230\u4e00\u4e2a Ack \u6d88\u606f\u65f6\uff0cPendingCheckpoint \u5c31\u4ece notYetAcknowledgedTasks \u4e2d\u79fb\u9664\u5bf9\u5e94\u7684 Task\uff0c\u5e76\u4fdd\u5b58 Ack \u643a\u5e26\u7684\u72b6\u6001\u53e5\u67c4\u4fdd\u5b58\u3002\u5f53 notYetAcknowledgedTasks \u4e3a\u7a7a\u65f6\uff0c\u8868\u660e\u6240\u6709\u7684 Ack \u6d88\u606f\u90fd\u63a5\u6536\u5230\u4e86\u3002"}),"\n",(0,a.jsx)(n.p,{children:"\u4e00\u65e6 PendingCheckpoint \u786e\u8ba4\u6240\u6709 Ack \u6d88\u606f\u90fd\u5df2\u7ecf\u63a5\u6536\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5b8c\u6210\u6b64\u6b21 checkpoint \u4e86\uff0c\u5177\u4f53\u5305\u62ec\uff1a"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u8c03\u7528 PendingCheckpoint.finalizeCheckpoint() \u5c06 PendingCheckpoint \u8f6c\u5316\u4e3a CompletedCheckpoint"}),"\n",(0,a.jsx)(n.li,{children:"\u83b7\u53d6 CheckpointMetadataOutputStream\uff0c\u5c06\u6240\u6709\u7684\u72b6\u6001\u53e5\u67c4\u4fe1\u606f\u901a\u8fc7 CheckpointMetadataOutputStream \u5199\u5165\u5230\u5b58\u50a8\u7cfb\u7edf\u4e2d"}),"\n",(0,a.jsx)(n.li,{children:"\u521b\u5efa\u4e00\u4e2a CompletedCheckpoint \u5bf9\u8c61"}),"\n",(0,a.jsx)(n.li,{children:"\u5c06 CompletedCheckpoint \u4fdd\u5b58\u5230 CompletedCheckpointStore \u4e2d"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"CompletedCheckpointStore \u6709\u4e24\u79cd\u5b9e\u73b0\uff0c\u5206\u522b\u4e3a StandaloneCompletedCheckpointStore \u548c ZooKeeperCompletedCheckpointStore"})," StandaloneCompletedCheckpointStore \u7b80\u5355\u5730\u5c06 CompletedCheckpointStore \u5b58\u653e\u5728\u4e00\u4e2a\u6570\u7ec4\u4e2d ",(0,a.jsxs)(n.strong,{children:["ZooKeeperCompletedCheckpointStore \u63d0\u4f9b\u9ad8\u53ef\u7528\u5b9e\u73b0\uff1a\u5148\u5c06 CompletedCheckpointStore \u5199\u5165\u5230 RetrievableStateStorageHelper \u4e2d\uff08\u901a\u5e38\u662f",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.strong,{children:"\u6587\u4ef6\u7cfb\u7edf"})}),"\uff09\uff0c\u7136\u540e\u5c06\u6587\u4ef6\u53e5\u67c4\u5b58\u5728 ZK \u4e2d"]})," \u4fdd\u5b58\u7684 CompletedCheckpointStore \u6570\u91cf\u662f\u6709\u9650\u7684\uff0c\u4f1a\u5220\u9664\u65e7\u7684\u5feb\u7167"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"\u79fb\u9664\u88ab\u8d8a\u8fc7\u7684 PendingCheckpoint\uff0c\u56e0\u4e3a CheckpointID \u662f\u9012\u589e\u7684\uff0c\u90a3\u4e48\u6240\u6709\u6bd4\u5f53\u524d\u5b8c\u6210\u7684 CheckpointID \u5c0f\u7684 PendingCheckpoint \u90fd\u53ef\u4ee5\u88ab\u4e22\u5f03\u4e86"}),"\n",(0,a.jsx)(n.li,{children:"\u4f9d\u6b21\u8c03\u7528 Execution.notifyCheckpointComplete() \u901a\u77e5\u6240\u6709\u7684 Task \u5f53\u524d Checkpoint \u5df2\u7ecf\u5b8c\u6210"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"\u901a\u8fc7 RPC \u8c03\u7528 TaskExecutor.confirmCheckpoint() \u544a\u77e5\u5bf9\u5e94\u7684 Task"}),"\n",(0,a.jsx)(n.p,{children:"Task\u6536\u5230notifyCheckpointComplete\u786e\u8ba4\u540e\u8fdb\u884c\u540e\u7eed\u5904\u7406\uff0c\u6bd4\u5982kafkaproduce\u7684\u4e24\u6bb5\u5f0f\u63d0\u4ea4\u8fc7\u7a0b\u3002"})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(6540);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);